--  Copyright 1991-2012 Corporation  
--  Your use of Altera Corporation's design tools, logic functions  
--  and other software and tools, and its AMPP partner logic  
--  functions, and any output files from any of the foregoing  
--  (including device programming or simulation files), and any  
--  associated documentation or information are expressly subject  
--  to the terms and conditions of the Altera Program License  
--  Subscription Agreement, Altera MegaCore Function License  
--  Agreement, or other applicable license agreement, including,  
--  without limitation, that your use is for the sole purpose of  
--  programming logic devices manufactured by Altera and sold by  
--  Altera or its authorized distributors.  Please refer to the  
--  applicable agreement for further details. 
--  
--  12.0 Build 178  05/31/2012   
--
--	Version 1.0

OPTIONS NAME_SUBSTITUTION = ON;
OPTIONS TREAT_DEFAULT_VALUE_AS_UNUSED = ON;

include "stratix_ram_block.inc";
include "lpm_mux";
include "lpm_decode";
include "aglobal120.inc";
include "a_rdenreg";
include "altrom.inc";
include "altram.inc";
include "altdpram.inc";


PARAMETERS
(
	-- mode selection parameter
	OPERATION_MODE = "BIDIR_DUAL_PORT",

	----------------------------
	-- port A parameters --
	----------------------------
	WIDTH_A = 1,					
	WIDTHAD_A = 1,			
	NUMWORDS_A = 1,		
	-- registering parameters
	OUTDATA_REG_A = "UNREGISTERED",			
	-- clearing parameters
	ADDRESS_ACLR_A = "NONE",						
	OUTDATA_ACLR_A = "NONE",	
	WRCONTROL_ACLR_A = "NONE",			
	INDATA_ACLR_A = "NONE",
	BYTEENA_ACLR_A = "NONE",

	----------------------------
	-- port B parameter --
	----------------------------
	WIDTH_B = 1,
	WIDTHAD_B = 1,
	NUMWORDS_B = 1,
	-- registering parameters
	INDATA_REG_B = "CLOCK1",
	WRCONTROL_WRADDRESS_REG_B = "CLOCK1",
	RDCONTROL_REG_B = "CLOCK1",	
	ADDRESS_REG_B = "CLOCK1",	
	OUTDATA_REG_B = "UNREGISTERED",
	BYTEENA_REG_B = "CLOCK1",

	-- clearing parameters
	INDATA_ACLR_B = "NONE",
	WRCONTROL_ACLR_B = "NONE",		
	ADDRESS_ACLR_B = "NONE",								
	OUTDATA_ACLR_B = "NONE",	
	RDCONTROL_ACLR_B = "NONE",
	BYTEENA_ACLR_B = "NONE",

	-- byte enable parameters
	WIDTH_BYTEENA_A = 1,
	WIDTH_BYTEENA_B = 1,

	-- RAM block type choices are "AUTO", "SMALL", "MEDIUM" and "LARGE"
	RAM_BLOCK_TYPE = "AUTO",

	-- width of a byte for byte enables
	BYTE_SIZE = 8,
	
	-- Mixed port feed through mode choices are
	-- OLD_DATA and DONT_CARE
	READ_DURING_WRITE_MODE_MIXED_PORTS = "DONT_CARE",
	READ_DURING_WRITE_MODE_PORT_A = "NEW_DATA_NO_NBE_READ",
	READ_DURING_WRITE_MODE_PORT_B = "NEW_DATA_NO_NBE_READ",
		
	-- General operation parameters
	INIT_FILE = "UNUSED",
	INIT_FILE_LAYOUT = "PORT_A",			
	MAXIMUM_DEPTH = 0,			
	CLOCK_ENABLE_INPUT_A = "NORMAL", -- choices are normal and bypass not valid for Stratix
	CLOCK_ENABLE_INPUT_B = "NORMAL", -- choices are normal and bypass not valid for Stratix	
	CLOCK_ENABLE_OUTPUT_A = "NORMAL", -- choices are normal and bypass not valid for Stratix
	CLOCK_ENABLE_OUTPUT_B = "NORMAL", -- choices are normal and bypass not valid for Stratix	
	CLOCK_ENABLE_CORE_A = "USE_INPUT_CLKEN",
	CLOCK_ENABLE_CORE_B = "USE_INPUT_CLKEN",
	ENABLE_ECC = "FALSE",
	ECC_PIPELINE_STAGE_ENABLED = "FALSE",
	WIDTH_ECCSTATUS = 3,
	DEVICE_FAMILY,
	CBXI_PARAMETER = "NOTHING"
);

FUNCTION @CBXI_PARAMETER ( wren_a, wren_b, rden_a, data_a[WIDTH_A - 1..0], data_b[WIDTH_B - 1..0], address_a[WIDTHAD_A - 1..0], address_b[WIDTHAD_B - 1..0], addressstall_a, addressstall_b, clock0, clock1, clocken0, clocken1, clocken2, clocken3, rden_b, aclr0, aclr1, byteena_a[WIDTH_BYTEENA_A - 1..0], byteena_b[WIDTH_BYTEENA_B - 1..0]) WITH (OPERATION_MODE, WIDTH_A, WIDTHAD_A, NUMWORDS_A, INDATA_ACLR_A, WRCONTROL_ACLR_A, ADDRESS_ACLR_A, WIDTH_B, WIDTHAD_B, NUMWORDS_B, INDATA_REG_B, INDATA_ACLR_B, WRCONTROL_WRADDRESS_REG_B, WRCONTROL_ACLR_B, ADDRESS_ACLR_B, OUTDATA_REG_A, OUTDATA_ACLR_A, BYTEENA_REG_B, BYTEENA_ACLR_B, INIT_FILE, INIT_FILE_LAYOUT, MAXIMUM_DEPTH, WIDTH_BYTEENA_A, WIDTH_BYTEENA_B, BYTE_SIZE, READ_DURING_WRITE_MODE_MIXED_PORTS, RAM_BLOCK_TYPE, CLOCK_ENABLE_INPUT_A, CLOCK_ENABLE_INPUT_B, CLOCK_ENABLE_OUTPUT_A, CLOCK_ENABLE_OUTPUT_B) RETURNS (q_a[WIDTH_A - 1..0], q_b[WIDTH_B - 1..0], eccstatus[WIDTH_ECCSTATUS-1..0]);

FUNCTION altsyncram ( wren_a, wren_b, rden_a, data_a[WIDTH_A - 1..0], data_b[WIDTH_B - 1..0], address_a[WIDTHAD_A - 1..0], address_b[WIDTHAD_B - 1..0], addressstall_a, addressstall_b, clock0, clock1, clocken0, clocken1, clocken2, clocken3, rden_b, aclr0, aclr1, byteena_a[WIDTH_BYTEENA_A - 1..0], byteena_b[WIDTH_BYTEENA_B - 1..0]) WITH (OPERATION_MODE, WIDTH_A, WIDTHAD_A, NUMWORDS_A, INDATA_ACLR_A, WRCONTROL_ACLR_A, ADDRESS_ACLR_A, WIDTH_B, WIDTHAD_B, NUMWORDS_B, INDATA_REG_B, INDATA_ACLR_B, WRCONTROL_WRADDRESS_REG_B, WRCONTROL_ACLR_B, ADDRESS_ACLR_B, OUTDATA_REG_A, OUTDATA_ACLR_A, BYTEENA_REG_B, BYTEENA_ACLR_B, INIT_FILE, INIT_FILE_LAYOUT, MAXIMUM_DEPTH, WIDTH_BYTEENA_A, WIDTH_BYTEENA_B, BYTE_SIZE, READ_DURING_WRITE_MODE_MIXED_PORTS, RAM_BLOCK_TYPE, CLOCK_ENABLE_INPUT_A, CLOCK_ENABLE_INPUT_B, CLOCK_ENABLE_OUTPUT_A, CLOCK_ENABLE_OUTPUT_B) RETURNS (q_a[WIDTH_A - 1..0], q_b[WIDTH_B - 1..0], eccstatus[WIDTH_ECCSTATUS-1..0]);



CONSTANT INTERNAL_FILE 			=	 USED(INIT_FILE) ? INIT_FILE : "UNUSED";
CONSTANT LOGICAL_RAM_NAME 		=	 "ALTSYNCRAM INSTANTIATION";
CONSTANT NUM_WORDS_A 			=	 USED(NUMWORDS_A) & NUMWORDS_A != 0 ? NUMWORDS_A : 2^WIDTHAD_A;
CONSTANT NUM_WORDS_B			=	 USED(NUMWORDS_B) & NUMWORDS_B != 0 ? NUMWORDS_B : 2^WIDTHAD_B;



-- mode #defines
DEFINE ROM_MODE() 				=	 OPERATION_MODE == "ROM";
DEFINE SINGLE_PORT_MODE() 		=	 OPERATION_MODE == "SINGLE_PORT";
DEFINE DUAL_PORT_MODE() 		=	 OPERATION_MODE == "DUAL_PORT";
DEFINE BIDIR_DUAL_PORT_MODE()	=	 OPERATION_MODE == "BIDIR_DUAL_PORT";
DEFINE RAM_BLOCK_TYPE()			=	 RAM_BLOCK_TYPE == "M512" & FAMILY_HAS_M512() == 1 ? "SMALL" : (RAM_BLOCK_TYPE == "M4K" ? "MEDIUM" : ((RAM_BLOCK_TYPE == "MEGARAM" # RAM_BLOCK_TYPE == "M-RAM") & FAMILY_HAS_MEGARAM() == 1 ? "LARGE" : "AUTO"));
DEFINE RAM_BLOCK_TYPE_WYS()		=	 RAM_BLOCK_TYPE == "M512" & FAMILY_HAS_M512() == 1 ? "M512" : (RAM_BLOCK_TYPE == "M4K" ? "M4K" : ((RAM_BLOCK_TYPE == "MEGARAM" # RAM_BLOCK_TYPE == "M-RAM") & FAMILY_HAS_MEGARAM() == 1 ? "MEGARAM" : "AUTO"));

-- end mode #defines

-- General port a #defines
DEFINE PORT_A_DATA_OUT_CLOCK() 		=	 OUTDATA_REG_A == "UNREGISTERED" ? "NONE" : OUTDATA_REG_A;
DEFINE PORT_A_DATA_OUT_CLEAR() 		=	 USED(OUTDATA_REG_A) & OUTDATA_REG_A != "UNREGISTERED" ? OUTDATA_ACLR_A : "NONE";
DEFINE PORT_B_DATA_OUT_CLOCK() 		=	 OUTDATA_REG_B == "UNREGISTERED" ? "NONE" : OUTDATA_REG_B;
DEFINE PORT_B_DATA_OUT_CLEAR() 		=	 USED(OUTDATA_REG_B) & OUTDATA_REG_B != "UNREGISTERED" ? OUTDATA_ACLR_B : "NONE";
DEFINE PORT_A_ADDRESS_CLEAR() 		=	 ADDRESS_ACLR_A;
DEFINE PORT_A_DATA_IN_CLEAR()		=	 INDATA_ACLR_A;
DEFINE PORT_A_WRITE_ENABLE_CLEAR()	=	 WRCONTROL_ACLR_A;
DEFINE SET_BYTEENA_ACLR_A()			=	 ((SINGLE_PORT_MODE() & !SP_SPECIAL_BYTEENA()) # (DUAL_PORT_MODE() & !DP_SPECIAL_BYTEENA()) # (BIDIR_DUAL_PORT_MODE() & !BDP_SPECIAL_BYTEENA() & !BDP_MRAM_SPECIAL_BYTEENA_PORT_A())) ? BYTEENA_ACLR_A : "UNUSED"; 
DEFINE SET_BYTEENA_ACLR_B()			=	 ((BIDIR_DUAL_PORT_MODE() & !BDP_SPECIAL_BYTEENA()& !BDP_MRAM_SPECIAL_BYTEENA_PORT_B())) ? BYTEENA_ACLR_B : "UNUSED"; 
DEFINE SET_BYTEENA_REG_B()			=	 ((BIDIR_DUAL_PORT_MODE() & !BDP_SPECIAL_BYTEENA()& !BDP_MRAM_SPECIAL_BYTEENA_PORT_B())) ? BYTEENA_REG_B : "UNUSED"; 
DEFINE PORT_A_BYTE_ENABLE_CLEAR() 	=	 USED(byteena_a) ? SET_BYTEENA_ACLR_A() : "UNUSED";
DEFINE PORT_B_BYTE_ENABLE_CLOCK()	=	 USED(byteena_b) ? SET_BYTEENA_REG_B() : "UNUSED";
DEFINE PORT_B_BYTE_ENABLE_CLEAR() 	=	 USED(byteena_b) ? SET_BYTEENA_ACLR_B() : "UNUSED";
DEFINE OUTPUT_A_REGISTERED()		=	 OUTDATA_REG_A == "CLOCK0" # OUTDATA_REG_A == "CLOCK1";
DEFINE OUTPUT_B_REGISTERED()		=	 OUTDATA_REG_B == "CLOCK0" # OUTDATA_REG_B == "CLOCK1";
DEFINE YGR_MIXED_PORT_FEED_THROUGH_MODE()	=	 (READ_DURING_WRITE_MODE_MIXED_PORTS == "OLD_DATA" ? "OLD" : (READ_DURING_WRITE_MODE_MIXED_PORTS == "DONT_CARE" ? "DONT_CARE" : "UNUSED"));

DEFINE ROM_MODE_CHECK()				=	 ROM_MODE();
DEFINE SINGLE_MODE_CHECK()			=	 SINGLE_PORT_MODE() & ((SP_SPECIAL_BYTEENA() & (ADDRESS_ACLR_A == "CLEAR0" # INDATA_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED") # WRCONTROL_ACLR_A == "CLEAR0")) # !SP_SPECIAL_BYTEENA());
DEFINE DUAL_MODE_CHECK()			=	 DUAL_PORT_MODE() & ((DP_SPECIAL_BYTEENA() & (ADDRESS_ACLR_A == "CLEAR0" # INDATA_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_B == "CLEAR0" & OUTDATA_REG_B != "UNREGISTERED") # WRCONTROL_ACLR_A == "CLEAR0" # ADDRESS_ACLR_B == "CLEAR0" # (USED(rden_b) & RDCONTROL_ACLR_B == "CLEAR0"))) # !DP_SPECIAL_BYTEENA());
DEFINE BIDIR_MODE_CHECK()			=	 BIDIR_DUAL_PORT_MODE() & ((BDP_SPECIAL_BYTEENA() & (ADDRESS_ACLR_A == "CLEAR0" # INDATA_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED") # (OUTDATA_ACLR_B == "CLEAR0" & OUTDATA_REG_B != "UNREGISTERED") # WRCONTROL_ACLR_A == "CLEAR0" # ADDRESS_ACLR_B == "CLEAR0" # INDATA_ACLR_B == "CLEAR0" # WRCONTROL_ACLR_B == "CLEAR0")) # !BDP_SPECIAL_BYTEENA());
DEFINE NEED_TO_CONNECT_CLEAR0()		=	 ROM_MODE_CHECK() # SINGLE_MODE_CHECK() # DUAL_MODE_CHECK() # BIDIR_MODE_CHECK();
DEFINE SINGLE_MODE_CHECK_CLR1()		=	 SINGLE_PORT_MODE() & ((SP_SPECIAL_BYTEENA() & (OUTDATA_ACLR_A == "CLEAR1" & OUTDATA_REG_A != "UNREGISTERED")) # !SP_SPECIAL_BYTEENA());
DEFINE DUAL_MODE_CHECK_CLR1()		=	 DUAL_PORT_MODE() & ((DP_SPECIAL_BYTEENA() & ((OUTDATA_ACLR_B == "CLEAR1" & OUTDATA_REG_B != "UNREGISTERED") # ADDRESS_ACLR_B == "CLEAR1" # (USED(rden_b) & RDCONTROL_ACLR_B == "CLEAR1"))) # !DP_SPECIAL_BYTEENA());
DEFINE BIDIR_MODE_CHECK_CLR1()		=	 BIDIR_DUAL_PORT_MODE() & ((BDP_SPECIAL_BYTEENA() & ((OUTDATA_ACLR_A == "CLEAR1" & OUTDATA_REG_A != "UNREGISTERED") # (OUTDATA_ACLR_B == "CLEAR1" & OUTDATA_REG_B != "UNREGISTERED") # ADDRESS_ACLR_B == "CLEAR1" # INDATA_ACLR_B == "CLEAR1" # WRCONTROL_ACLR_B == "CLEAR1")) # !BDP_SPECIAL_BYTEENA());
DEFINE NEED_TO_CONNECT_CLEAR1()		=	 ROM_MODE_CHECK() # SINGLE_MODE_CHECK_CLR1() # DUAL_MODE_CHECK_CLR1() # BIDIR_MODE_CHECK_CLR1();

-- end port a defines

-- ROM #defines
DEFINE ROM_MAX_DEPTH() 				=	 RAM_BLOCK_TYPE() == "SMALL" ? 512 : (RAM_BLOCK_TYPE() == "MEDIUM" ? 4096 : (RAM_BLOCK_TYPE() == "AUTO" ? 4096 : 4096)) ;
DEFINE ROM_ADDRESS_SIZE() 			=	 CEIL(LOG2(MAXIMUM_SEGMENT_DEPTH_ROM())) ;
DEFINE ROM_PORT_A_FIRST_ADDRESS(j) 	=	 (j*MAXIMUM_SEGMENT_DEPTH_ROM());
DEFINE ROM_PORT_A_LAST_ADDRESS(j) 	=	 ((j+1)*MAXIMUM_SEGMENT_DEPTH_ROM() - 1 > NUM_WORDS_A-1) ? NUM_WORDS_A-1 : (j+1)*MAXIMUM_SEGMENT_DEPTH_ROM() - 1;
DEFINE NUMBER_OF_ROM_SLICES() 		=	 WIDTH_A;
DEFINE MAXIMUM_SEGMENT_DEPTH_ROM() 	=	 MAXIMUM_DEPTH == 0 ? ROM_MAX_DEPTH() : (MAXIMUM_DEPTH > ROM_MAX_DEPTH() ? ROM_MAX_DEPTH() : MAXIMUM_DEPTH);
DEFINE NUMBER_OF_ROM_SEGMENTS() 	=	 CEIL(NUM_WORDS_A / MAXIMUM_SEGMENT_DEPTH_ROM());
DEFINE ROM_UPPER_ADDRESS()			=	 WIDTHAD_A - ROM_ADDRESS_SIZE();		
DEFINE ROM_LAST_SEGMENT_DEPTH()		=	 NUM_WORDS_A - ((NUMBER_OF_ROM_SEGMENTS()-1) * MAXIMUM_SEGMENT_DEPTH_ROM());
DEFINE ROM_LAST_SEGMENT_ADDRESS()	=	 ROM_LAST_SEGMENT_DEPTH() == 1 ? 1 : CEIL(LOG2(ROM_LAST_SEGMENT_DEPTH()));
-- end ROM #defines

DEFINE SP_INPUT_REGR_CLEARS()		=	 (INDATA_ACLR_A == "NONE" # !USED(INDATA_ACLR_A)) & (ADDRESS_ACLR_A == "NONE" # !USED(ADDRESS_ACLR_A)) & (WRCONTROL_ACLR_A == "NONE" # !USED(WRCONTROL_ACLR_A)) & ((USED(byteena_a) & (BYTEENA_ACLR_A == "NONE" # !USED(BYTEENA_ACLR_A))) # !USED(byteena_a));

-- Single port #defines
DEFINE SP_CHOOSE_AUTO()						=	 SP_INPUT_REGR_CLEARS()&  (!USED(INIT_FILE)) & FAMILY_HAS_MEGARAM();
DEFINE SP_CHOOSE_LARGE()					=	 (SP_CHOOSE_AUTO() == 1) ?  "LARGE" : "MEDIUM";
DEFINE SP_AUTO_MAX_DEPTH_BIT()				=	 SP_CHOOSE_LARGE() == "LARGE" ?   65536 : 4096;
DEFINE SP_AUTO_MAX_DEPTH_BYTE()				=	 SP_CHOOSE_LARGE() == "LARGE" ?   65536 : 512;
DEFINE SP_AUTO_ADDRESS_SIZE_BIT()			=	 SP_CHOOSE_LARGE() == "LARGE" ?   16 : 12;
DEFINE SP_AUTO_ADDRESS_SIZE_BYTE()			=	 SP_CHOOSE_LARGE() == "LARGE" ?   16 : 9;
DEFINE SP_PORT_A_FIRST_ADDRESS(j) 			=	 (j*MAXIMUM_SEGMENT_DEPTH_SINGLE_PORT());
DEFINE SP_PORT_A_LAST_ADDRESS(j) 			=	 (((j+1)*MAXIMUM_SEGMENT_DEPTH_SINGLE_PORT()-1) > NUM_WORDS_A-1) ? NUM_WORDS_A-1 : (j+1)*MAXIMUM_SEGMENT_DEPTH_SINGLE_PORT()-1;
DEFINE SINGLE_PORT_MAX_DEPTH_BIT()			=	 RAM_BLOCK_TYPE() == "SMALL" ? 512 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  4096 : (RAM_BLOCK_TYPE() == "LARGE" ? 65536 : SP_AUTO_MAX_DEPTH_BIT()));
DEFINE SINGLE_PORT_MAX_DEPTH_BYTE()			=	 RAM_BLOCK_TYPE() == "SMALL" ? 64 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  512 : (RAM_BLOCK_TYPE() == "LARGE" ? 65536 : SP_AUTO_MAX_DEPTH_BYTE()));
DEFINE SINGLE_PORT_ADDRESS_SIZE_BIT()		=	 RAM_BLOCK_TYPE() == "SMALL" ? 9 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  12 : (RAM_BLOCK_TYPE() == "LARGE" ? 16 : SP_AUTO_ADDRESS_SIZE_BIT()));
DEFINE SINGLE_PORT_ADDRESS_SIZE_BYTE()		=	 RAM_BLOCK_TYPE() == "SMALL" ? 6 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  9 : (RAM_BLOCK_TYPE() == "LARGE" ? 16 : SP_AUTO_ADDRESS_SIZE_BYTE()));
DEFINE NUMBER_OF_SINGLE_PORT_SLICES()		= 	 !USED(byteena_a) # SP_SPECIAL_BYTEENA() ? WIDTH_A : WIDTH_BYTEENA_A;
DEFINE MAXIMUM_SEGMENT_DEPTH_SINGLE_PORT()	=	 MAXIMUM_DEPTH == 0 ? (!USED(byteena_a) # SP_SPECIAL_BYTEENA() ? SINGLE_PORT_MAX_DEPTH_BIT(): SINGLE_PORT_MAX_DEPTH_BYTE()) : (USED(byteena_a) & !SP_SPECIAL_BYTEENA() ? (MAXIMUM_DEPTH > SINGLE_PORT_MAX_DEPTH_BYTE() ? SINGLE_PORT_MAX_DEPTH_BYTE(): MAXIMUM_DEPTH ) : (MAXIMUM_DEPTH > SINGLE_PORT_MAX_DEPTH_BIT() ? SINGLE_PORT_MAX_DEPTH_BIT() : MAXIMUM_DEPTH));
DEFINE NUMBER_OF_SINGLE_PORT_SEGMENTS()		=	 CEIL(NUM_WORDS_A / MAXIMUM_SEGMENT_DEPTH_SINGLE_PORT());
DEFINE SP_PORT_A_FIRST_BIT_NUMBER(j)		=	 !USED(byteena_a) # SP_SPECIAL_BYTEENA() ? j : BYTE_SIZE*j; 
DEFINE SP_PORT_A_DATA_WIDTH()				=	 !USED(byteena_a) # SP_SPECIAL_BYTEENA() ? 1 : BYTE_SIZE;
DEFINE SINGLE_PORT_ADDRESS_SIZE()			=	 CEIL(LOG2(MAXIMUM_SEGMENT_DEPTH_SINGLE_PORT()));
DEFINE SP_UPPER_ADDRESS()					=	 WIDTHAD_A - SINGLE_PORT_ADDRESS_SIZE();
DEFINE BLOCK_ID(i)							=	 FLOOR(i / BYTE_SIZE);
DEFINE NORMALIZE(i)							=	 i - BLOCK_ID(i)*BYTE_SIZE;
DEFINE SINGLE_PORT_LAST_SEGMENT_DEPTH()		=	 NUM_WORDS_A - ((NUMBER_OF_SINGLE_PORT_SEGMENTS()-1) * MAXIMUM_SEGMENT_DEPTH_SINGLE_PORT());
DEFINE SINGLE_PORT_LAST_SEGMENT_ADDRESS()	=	 SINGLE_PORT_LAST_SEGMENT_DEPTH() == 1 ? 1 : CEIL(LOG2(SINGLE_PORT_LAST_SEGMENT_DEPTH()));

DEFINE SP_DEPTH_CHECK()						=	 RAM_BLOCK_TYPE() == "MEDIUM" ? (NUM_WORDS_A > 256) : (RAM_BLOCK_TYPE() == "LARGE" ? (NUM_WORDS_A > 32768) : (SP_CHOOSE_LARGE() == "LARGE" ? NUM_WORDS_A > 256 : NUM_WORDS_A > 256));
DEFINE SP_SPECIAL_BYTEENA()					=	 USED(byteena_a) & SP_DEPTH_CHECK();
-- end Single port #defines

--Dual port #defines
DEFINE DP_CHOOSE_AUTO()						=	 SP_CHOOSE_AUTO() & (ADDRESS_ACLR_B == "NONE" # !USED(ADDRESS_ACLR_B)) & !USED(rden_b) & DP_MRAM_RATIO() & (READ_DURING_WRITE_MODE_MIXED_PORTS != "OLD_DATA") & FAMILY_HAS_MEGARAM();
DEFINE DP_MEAB_NO_BYTE_RATIO()				=	 RATIO() == 1 # RATIO() == 2 # RATIO() == 4 # RATIO() == 8 # RATIO() == 16 # RATIO() == 32;
DEFINE DP_MEAB_BYTE_RATIO()					=	 (((RATIO() == 1) # (RATIO() == 2) # (RATIO() == 4))& MULTIPLE(WIDTH_A) & MULTIPLE(WIDTH_B))# SPECIAL_DP_COMBINATION(); 
DEFINE DP_MRAM_RATIO()						=	 USED(byteena_a) ? DP_MRAM_BYTE_RATIO() : DP_MRAM_NO_BYTE_RATIO();
DEFINE DP_MRAM_BYTE_RATIO()					=	 (RATIO() == 1 # RATIO() == 2 # RATIO() == 4 # RATIO() == 8) & MULTIPLE(WIDTH_A) & MULTIPLE(WIDTH_B);
DEFINE DP_MRAM_NO_BYTE_RATIO()				=	 (RATIO() == 1 # RATIO() == 2 # RATIO() == 4 # RATIO() == 8);
DEFINE DP_CHOOSE_AUTO_RATIO_CHK()			=	 (USED(byteena_a) ? DP_MEAB_BYTE_RATIO() : DP_MEAB_NO_BYTE_RATIO());  
DEFINE DP_CHOOSE_LARGE()					=	 (DP_CHOOSE_AUTO() == 1) ? "LARGE" : (DP_CHOOSE_AUTO_RATIO_CHK() ? "MEDIUM" : "MEDIUM");
DEFINE DP_AUTO_MAX_DEPTH_BIT()				=	 DP_CHOOSE_LARGE() == "LARGE" ?   65536 : 4096;
DEFINE DP_AUTO_MAX_DEPTH_BYTE()				=	 DP_CHOOSE_LARGE() == "LARGE" ?   65536 : 512;
DEFINE DP_AUTO_ADDRESS_SIZE_BIT()			=	 DP_CHOOSE_LARGE() == "LARGE" ?   16 : 12;
DEFINE DP_AUTO_ADDRESS_SIZE_BYTE()			=	 DP_CHOOSE_LARGE() == "LARGE" ?   16 : 9;
DEFINE DP_VALID_AUTO_COMBINATION()			=	 (RATIO_REM() == 0 )& ((DP_CHOOSE_AUTO()) # (!DP_CHOOSE_AUTO() & DP_CHOOSE_AUTO_RATIO_CHK()));

-- valid combination
DEFINE RATIO()								=	 WIDTH_A > WIDTH_B ? WIDTH_A / WIDTH_B : WIDTH_B / WIDTH_A;
DEFINE RATIO_REM()							=	 WIDTH_A > WIDTH_B ? WIDTH_A mod WIDTH_B : WIDTH_B mod WIDTH_A;
DEFINE VALID_BYTEENA_RATIO_1()				=	 RATIO() == 1 # RATIO() == 2 # RATIO() == 4 # RATIO() == 8;
DEFINE VALID_BYTEENA_RATIO()				=	 VALID_BYTEENA_RATIO_1() & (MULTIPLE(WIDTH_A)) & (MULTIPLE(WIDTH_B));
DEFINE BYTEENA_VALID_COMBINATION()			=	 RAM_BLOCK_TYPE() == "LARGE" ?  VALID_BYTEENA_RATIO() : (RAM_BLOCK_TYPE() == "MEDIUM" ? DP_MEAB_BYTE_RATIO() : WIDTH_A == WIDTH_B);
DEFINE VALID_NO_BYTEENA_RATIO()				=	 RATIO() == 1 # RATIO() == 2 # RATIO() == 4 # RATIO() == 8 # RATIO() == 16;
DEFINE VALID_MRAM_RATIO_1()					=	 RATIO() == 1 # RATIO() == 2 # RATIO() == 4 # RATIO() == 8;
DEFINE VALID_MRAM_RATIO()					=	 USED(byteena_a) ? VALID_MRAM_RATIO_1() & MULTIPLE(WIDTH_A) & MULTIPLE(WIDTH_B) : VALID_MRAM_RATIO_1();
DEFINE NO_BYTEENA_VALID_COMBINATION()		=	 RAM_BLOCK_TYPE() == "LARGE" ?  VALID_MRAM_RATIO() : (RAM_BLOCK_TYPE() == "MEDIUM" ? VALID_NO_BYTEENA_RATIO()# RATIO() == 32 : VALID_NO_BYTEENA_RATIO());
DEFINE DUAL_PORT_VALID_COMBINATION_1()		=	 !USED(byteena_a) ? NO_BYTEENA_VALID_COMBINATION() : BYTEENA_VALID_COMBINATION();
DEFINE MULTIPLE(x) 							=	 (x >= BYTE_SIZE) & (x mod BYTE_SIZE == 0);
DEFINE DUAL_PORT_VALID_COMBINATION()		=	 (RATIO_REM() == 0 )& (USED(byteena_a) & (RAM_BLOCK_TYPE() == "MEDIUM") ? DUAL_PORT_VALID_COMBINATION_1() # SPECIAL_DP_COMBINATION() : DUAL_PORT_VALID_COMBINATION_1());
DEFINE SPECIAL_DP_COMBINATION()				=	 ((WIDTH_B == 1 # WIDTH_B == 2) & (WIDTH_A == 16 # WIDTH_A == 32)) # ((WIDTH_B == 4) & (WIDTH_A == 16));
--number of slices
DEFINE DONT_SPLIT()							=	 (RAM_BLOCK_TYPE() == "MEDIUM" & USED(byteena_a) & SPECIAL_DP_COMBINATION()) # (RAM_BLOCK_TYPE() == "AUTO" & DP_CHOOSE_LARGE() == "MEDIUM" & USED(byteena_a) & SPECIAL_DP_COMBINATION());
DEFINE DUAL_PORT_WIDTH()					=	 WIDTH_A > WIDTH_B ? WIDTH_B : WIDTH_A;
DEFINE DUAL_PORT_WIDTH_BYTEENA()			=	 DUAL_PORT_WIDTH() >= BYTE_SIZE ? DUAL_PORT_WIDTH() / BYTE_SIZE : 1;
DEFINE NUMBER_OF_DUAL_PORT_SLICES()			=	 DONT_SPLIT() ? 1 : ((USED(byteena_a) & !DP_SPECIAL_BYTEENA()) ? DUAL_PORT_WIDTH_BYTEENA() : DUAL_PORT_WIDTH());
-- number of segments()
DEFINE DUAL_PORT_LARGER_PORT_DEPTH()		=	 WIDTHAD_B > WIDTHAD_A ? NUM_WORDS_B : NUM_WORDS_A;
DEFINE DUAL_PORT_MAX_DEPTH_BIT()			=	 RAM_BLOCK_TYPE() == "SMALL" ? 512 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  4096 : (RAM_BLOCK_TYPE() == "LARGE" ? 65536 : DP_AUTO_MAX_DEPTH_BIT()));
DEFINE DUAL_PORT_ADDRESS_SIZE_BIT()			=	 RAM_BLOCK_TYPE() == "SMALL" ? 9 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  12 : (RAM_BLOCK_TYPE() == "LARGE" ? 16 : DP_AUTO_ADDRESS_SIZE_BIT()));
DEFINE DUAL_PORT_MAX_DEPTH_BYTE()			=	 RAM_BLOCK_TYPE() == "SMALL" ? 64 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  512 : (RAM_BLOCK_TYPE() == "LARGE" ? 65536 : DP_AUTO_MAX_DEPTH_BYTE()));
DEFINE DUAL_PORT_ADDRESS_SIZE_BYTE()		=	 RAM_BLOCK_TYPE() == "SMALL" ? 6 : (RAM_BLOCK_TYPE() == "MEDIUM" ?  9 : (RAM_BLOCK_TYPE() == "LARGE" ? 16 : DP_AUTO_ADDRESS_SIZE_BYTE()));
DEFINE DUAL_PORT_MAX_DEPTH()				=	 !USED(byteena_a) # DP_SPECIAL_BYTEENA() ? DUAL_PORT_MAX_DEPTH_BIT() : DUAL_PORT_MAX_DEPTH_BYTE();
DEFINE MAX_DEPTH_DP_NO_MAX()				=	 DUAL_PORT_MAX_DEPTH() > DUAL_PORT_LARGER_PORT_DEPTH() ? DUAL_PORT_LARGER_PORT_DEPTH() : DUAL_PORT_MAX_DEPTH();
DEFINE MAX_DEPTH_DP_MAX()					=	 MAX_DEPTH_DP_NO_MAX() > MAXIMUM_DEPTH	?  MAXIMUM_DEPTH : MAX_DEPTH_DP_NO_MAX();
DEFINE MAXIMUM_DEPTH_DUAL_PORT()			=	 MAXIMUM_DEPTH == 0 ? MAX_DEPTH_DP_NO_MAX() : MAX_DEPTH_DP_MAX();
DEFINE DP_SEGMENTS()						=	 WIDTH_A > WIDTH_B ? CEIL(NUM_WORDS_B /  MAXIMUM_DEPTH_DUAL_PORT()) : CEIL(NUM_WORDS_A / MAXIMUM_DEPTH_DUAL_PORT());
DEFINE NUMBER_OF_DUAL_PORT_SEGMENTS()		=	 DONT_SPLIT() ? DP_DONT_SPLIT_SEGMENTS()  : DP_SEGMENTS();
DEFINE DP_DONT_SPLIT_SEGMENTS()				=	 CEIL (NUM_WORDS_A / MAXIMUM_DONT_SPLIT_SEGMENT_DEPTH());
DEFINE MAXIMUM_DONT_SPLIT_SEGMENT_DEPTH()	=	 WIDTH_A == 16 ? 256 : (WIDTH_A == 32 ? 128 : 256);
--interleave bits
DEFINE MIXED_MODE()							=	 WIDTH_A != WIDTH_B;
DEFINE DP_DATA_INTERLEAVE_WIDTH()			=	 MIXED_MODE() ? (NUMBER_OF_DUAL_PORT_SLICES() == 1 ? 1 : (USED(byteena_a) & !DP_SPECIAL_BYTEENA() ? BYTE_SIZE : 1)) : "UNUSED";
DEFINE DP_DATA_INTERLEAVE_OFFSET()			=	 MIXED_MODE() ?  ((NUMBER_OF_DUAL_PORT_SLICES() == 1) ? 1 : (USED(byteena_a) & !DP_SPECIAL_BYTEENA() ? NUMBER_OF_DUAL_PORT_SLICES()* BYTE_SIZE : NUMBER_OF_DUAL_PORT_SLICES())) : "UNUSED";
-- data width of slices
DEFINE DP_A_WIDTH()							=	 WIDTH_A > WIDTH_B ? WIDTH_A / WIDTH_B : 1;
DEFINE DP_A_WIDTH_BYTEENA()					=	 (WIDTH_A > WIDTH_B) ? (WIDTH_A / WIDTH_B) * BYTE_SIZE : BYTE_SIZE;
DEFINE DP_PORT_A_DATA_WIDTH()				=	 DONT_SPLIT() ?  WIDTH_A : (USED(byteena_a) & !DP_SPECIAL_BYTEENA()) ? DP_A_WIDTH_BYTEENA() : DP_A_WIDTH();
DEFINE DP_B_WIDTH()							=	 WIDTH_A > WIDTH_B ? 1 : WIDTH_B / WIDTH_A;
DEFINE DP_B_WIDTH_BYTEENA()					=	 WIDTH_A > WIDTH_B ? BYTE_SIZE : (WIDTH_B / WIDTH_A) * BYTE_SIZE;
DEFINE DP_PORT_B_DATA_WIDTH()				=	 DONT_SPLIT() ?  WIDTH_B : (USED(byteena_a) & !DP_SPECIAL_BYTEENA()) ? DP_B_WIDTH_BYTEENA() : DP_B_WIDTH();

--first bit numbers
DEFINE DP_PORT_A_FIRST_BIT_NUMBER(j)		=	 USED(byteena_a) & !DP_SPECIAL_BYTEENA() ? j*BYTE_SIZE : j;
DEFINE DP_PORT_B_FIRST_BIT_NUMBER(j)		=	 USED(byteena_a) & !DP_SPECIAL_BYTEENA() ? j*BYTE_SIZE : j;

-- first address
DEFINE MAX_DEPTH_DP_A()						=	 DONT_SPLIT() ?  MAXIMUM_DONT_SPLIT_SEGMENT_DEPTH() : ((WIDTH_A > WIDTH_B) ? MAXIMUM_DEPTH_DUAL_PORT() / (WIDTH_A / WIDTH_B) : MAXIMUM_DEPTH_DUAL_PORT());
DEFINE MAX_DEPTH_DP_B()						=	 DONT_SPLIT() ?  MAXIMUM_DONT_SPLIT_SEGMENT_DEPTH() * (WIDTH_A / WIDTH_B)  : ((WIDTH_A > WIDTH_B) ? MAXIMUM_DEPTH_DUAL_PORT() : MAXIMUM_DEPTH_DUAL_PORT() / (WIDTH_B / WIDTH_A));
DEFINE DP_PORT_A_FIRST_ADDRESS(i)			=	 (i == 0) ? 0 : i * MAX_DEPTH_DP_A();	
DEFINE DP_PORT_B_FIRST_ADDRESS(i)			=	 (i == 0) ? 0 : i * MAX_DEPTH_DP_B();	

--last address
DEFINE DP_PORT_A_LAST_ADDRESS(i)			=	 ((i+1) * MAX_DEPTH_DP_A() - 1) > NUM_WORDS_A-1 ? NUM_WORDS_A-1 : (i+1) * MAX_DEPTH_DP_A() - 1;
DEFINE DP_PORT_B_LAST_ADDRESS(i)			=	 ((i+1) * MAX_DEPTH_DP_B() - 1) > NUM_WORDS_B-1 ? NUM_WORDS_B-1 : (i+1) * MAX_DEPTH_DP_B() - 1;

--connections macros
DEFINE NUMBER_OF_DUAL_PORT_BYTES()			=	 DONT_SPLIT() ? WIDTH_A / BYTE_SIZE : WIDTH_A / WIDTH_B;
DEFINE DP_BLOCK_ID_A(i)						=	 (WIDTH_A > WIDTH_B) ?  FLOOR(i / (BYTE_SIZE*NUMBER_OF_DUAL_PORT_BYTES)): FLOOR(i / BYTE_SIZE);
DEFINE DP_BLOCK_ID_B(i)						=	 (WIDTH_A > WIDTH_B) ?  FLOOR(i / BYTE_SIZE) : FLOOR (i / (BYTE_SIZE * (WIDTH_B / WIDTH_A)));
DEFINE DP_NORMALIZE_A(i)					=	 (WIDTH_A > WIDTH_B) ? i - DP_BLOCK_ID_A(i) * BYTE_SIZE * NUMBER_OF_DUAL_PORT_BYTES()  : i - DP_BLOCK_ID_A(i) * BYTE_SIZE;
DEFINE DP_NORMALIZE_B(i)					=	 (WIDTH_A > WIDTH_B) ? i - DP_BLOCK_ID_B(i) * BYTE_SIZE : i - (DP_BLOCK_ID_B(i) * BYTE_SIZE * (WIDTH_B / WIDTH_A));
DEFINE A_B_RATIO()							=	 WIDTH_A / WIDTH_B;
DEFINE B_A_RATIO()							=	 WIDTH_B / WIDTH_A;
DEFINE DP_BIT_BLOCK_ID_A(i)					=	 FLOOR(i / A_B_RATIO());
DEFINE DP_BIT_NORMALIZE_A(i)				=	 i - DP_BIT_BLOCK_ID_A(i) * A_B_RATIO();
DEFINE DP_BIT_BLOCK_ID_B(i)					=	 i MOD B_A_RATIO();
DEFINE DP_BIT_NORMALIZE_B(i)				=	 i - DP_BIT_BLOCK_ID_B(i) * B_A_RATIO();
DEFINE POSITION(i,j)						=	 (BIDIR_DUAL_PORT_MODE() ? i + NUMBER_OF_BIDIR_DUAL_PORT_SLICES()*j : i + NUMBER_OF_DUAL_PORT_SLICES()*j);
DEFINE BYTE_POSITION(i,j)					=	 i * BYTE_SIZE + FLOOR(j / BYTE_SIZE) * NUMBER_OF_DUAL_PORT_SLICES() * BYTE_SIZE + j MOD BYTE_SIZE;
--decode mux macros
DEFINE DUAL_PORT_ADDRESS_SIZE()				=	 DONT_SPLIT() ? (CEIL(LOG2(MAXIMUM_DONT_SPLIT_SEGMENT_DEPTH()))) : (CEIL(LOG2(MAXIMUM_DEPTH_DUAL_PORT())));
DEFINE DUAL_PORT_ADDRESS_SIZE_A()			=	 DONT_SPLIT() ? DUAL_PORT_ADDRESS_SIZE() : (WIDTHAD_A > WIDTHAD_B ? DUAL_PORT_ADDRESS_SIZE() : DUAL_PORT_ADDRESS_SIZE() - (WIDTHAD_B - WIDTHAD_A));
DEFINE DUAL_PORT_ADDRESS_SIZE_B()			=	 DONT_SPLIT() ? DUAL_PORT_ADDRESS_SIZE()+(WIDTHAD_B - WIDTHAD_A) :(WIDTHAD_B > WIDTHAD_A ? DUAL_PORT_ADDRESS_SIZE() : DUAL_PORT_ADDRESS_SIZE() - (WIDTHAD_A - WIDTHAD_B));
DEFINE DP_UPPER_ADDRESS()					=	 WIDTHAD_A - DUAL_PORT_ADDRESS_SIZE_A();

DEFINE DUAL_PORT_LAST_SEGMENT_DEPTH_A()		=	 DONT_SPLIT() ? (NUM_WORDS_A - MAX_DEPTH_DP_A()*(NUMBER_OF_DUAL_PORT_SEGMENTS()-1)) :(WIDTH_A > WIDTH_B ? (NUM_WORDS_B - ((NUMBER_OF_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_DUAL_PORT())) / (WIDTH_A / WIDTH_B) : NUM_WORDS_A - ((NUMBER_OF_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_DUAL_PORT()));
DEFINE DUAL_PORT_LAST_SEGMENT_ADDRESS_A()	=	 DUAL_PORT_LAST_SEGMENT_DEPTH_A() == 1 ? 1 : CEIL(LOG2(DUAL_PORT_LAST_SEGMENT_DEPTH_A()));
DEFINE DUAL_PORT_LAST_SEGMENT_DEPTH_B()		=	 DONT_SPLIT() ? (NUM_WORDS_B - MAX_DEPTH_DP_B()*(NUMBER_OF_DUAL_PORT_SEGMENTS()-1)) :(WIDTH_B > WIDTH_A ? (NUM_WORDS_A - ((NUMBER_OF_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_DUAL_PORT())) / (WIDTH_B / WIDTH_A) : NUM_WORDS_B - ((NUMBER_OF_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_DUAL_PORT()));
DEFINE DUAL_PORT_LAST_SEGMENT_ADDRESS_B()	=	 DUAL_PORT_LAST_SEGMENT_DEPTH_B() == 1 ? 1 : CEIL(LOG2(DUAL_PORT_LAST_SEGMENT_DEPTH_B()));

DEFINE DP_DEPTH_CHECK()						=	 RAM_BLOCK_TYPE() == "MEDIUM" ? (NUM_WORDS_A > 256 # RATIO() == 4) : (RAM_BLOCK_TYPE() == "LARGE" ? (NUM_WORDS_A > 32768) : (DP_CHOOSE_LARGE() == "LARGE" ? NUM_WORDS_A > 256 : NUM_WORDS_A > 256 # RATIO() == 4));
DEFINE DP_SPECIAL_BYTEENA()					=	 USED(byteena_a) & (WIDTH_A <= WIDTH_B) & DP_DEPTH_CHECK();
--end dual port #defines

--Bidir dual port defines
DEFINE BDP_CHOOSE_AUTO()					=	 DP_CHOOSE_AUTO() & (INDATA_ACLR_B == "NONE") & (WRCONTROL_ACLR_B == "NONE") & ((USED(byteena_b) & (BYTEENA_ACLR_B == "NONE" # !USED(BYTEENA_ACLR_B))) # !USED(byteena_b)) & FAMILY_HAS_MEGARAM();
DEFINE BDP_MEAB_BYTE_RATIO_1()				=	 ((RATIO() == 1) # (RATIO() == 2)) & MULTIPLE(WIDTH_A) & MULTIPLE(WIDTH_B);
DEFINE BDP_MEAB_BYTE_RATIO_2()				=	 ((RATIO() == 1) # (RATIO() == 2)) & MULTIPLE(WIDTH_A) & MULTIPLE(WIDTH_B);
DEFINE BDP_MEAB_BYTE_RATIO()				=	 USED(byteena_a) & !USED(byteena_b) ? SPECIAL_BDP_COMBINATION() # BDP_MEAB_BYTE_RATIO_1() : BDP_MEAB_BYTE_RATIO_2();
DEFINE BDP_MEAB_NO_BYTE_RATIO()				=	 RATIO() == 1 # RATIO() == 2 # RATIO() == 4 # RATIO() == 8 # RATIO() == 16;
DEFINE BDP_CHOOSE_AUTO_RATIO_CHK()			=	 (!USED(byteena_a) & !USED(byteena_b) ? BDP_MEAB_NO_BYTE_RATIO() : BDP_MEAB_BYTE_RATIO());  
DEFINE BDP_CHOOSE_LARGE()					=	 (BDP_CHOOSE_AUTO() == 1) ? "LARGE" : (BDP_CHOOSE_AUTO_RATIO_CHK() ? "MEDIUM" : "MEDIUM");
DEFINE BDP_AUTO_MAX_DEPTH_BIT()				=	 BDP_CHOOSE_LARGE() == "LARGE" ?   65536 : 4096;
DEFINE BDP_AUTO_MAX_DEPTH_BYTE()			=	 BDP_CHOOSE_LARGE() == "LARGE" ?   (!USED(byteena_b) & ((WIDTH_A != WIDTH_B) # ((WIDTH_A == WIDTH_B) & !USED(byteena_a))) ? 65536 : 65536) : 512;
DEFINE BDP_AUTO_ADDRESS_SIZE_BIT()			=	 BDP_CHOOSE_LARGE() == "LARGE" ?   16 : 12;
DEFINE BDP_AUTO_ADDRESS_SIZE_BYTE()			=	 BDP_CHOOSE_LARGE() == "LARGE" ?   (!USED(byteena_b) & ((WIDTH_A != WIDTH_B) # ((WIDTH_A == WIDTH_B) & !USED(byteena_a))) ? 16 : 16) : 9;
DEFINE BDP_VALID_AUTO_COMBINATION()			=	 SWAP_NEEDED() ? 1 : (RATIO_REM() == 0 )& ((DP_CHOOSE_AUTO()) # (!DP_CHOOSE_AUTO() & BDP_CHOOSE_AUTO_RATIO_CHK()));
DEFINE SPECIAL_BDP_COMBINATION()			=	 (WIDTH_A == 16) & ((WIDTH_B == 1) # (WIDTH_B == 2) # (WIDTH_B == 4));

-- valid combination
DEFINE BDP_NO_BYTEENA_VALID_COMBINATION()	=	 RAM_BLOCK_TYPE() == "LARGE" ?  BDP_VALID_BYTEENA_RATIO() : BDP_VALID_NO_BYTEENA_RATIO();
DEFINE BDP_BYTEENA_VALID_COMBINATION()		=	 RAM_BLOCK_TYPE() == "LARGE" ?  BDP_VALID_BYTEENA_RATIO() : BDP_MEAB_NO_BYTEENA_RATIO();
DEFINE BDP_VALID_BYTEENA_RATIO()			=	 (RATIO() == 1) # (RATIO() == 2) # (RATIO() == 4) # (RATIO() == 8);
DEFINE BDP_VALID_NO_BYTEENA_RATIO()			=	 BDP_VALID_BYTEENA_RATIO() # (RATIO() == 16);
DEFINE BDP_MEAB_NO_BYTEENA_RATIO()			=	 (RATIO() == 1) # (RATIO() == 2);
DEFINE BIDIR_DUAL_PORT_VALID_COMBINATION()	=	 SWAP_NEEDED() ? 1 : (RATIO_REM() == 0 )& (!USED(byteena_a) & !USED(byteena_b) ? BDP_NO_BYTEENA_VALID_COMBINATION() : (USED(byteena_a) & !USED(byteena_b) & RAM_BLOCK_TYPE() == "MEDIUM" ? BDP_BYTEENA_VALID_COMBINATION() # SPECIAL_BDP_COMBINATION() : BDP_BYTEENA_VALID_COMBINATION()));

DEFINE BDP_DONT_SPLIT()						=	 (RAM_BLOCK_TYPE() == "MEDIUM" & USED(byteena_a) & !USED(byteena_b) & SPECIAL_BDP_COMBINATION()) # (RAM_BLOCK_TYPE() == "AUTO" & BDP_CHOOSE_LARGE() == "MEDIUM" & USED(byteena_a) & !USED(byteena_b) & SPECIAL_BDP_COMBINATION());
--number of slices
DEFINE NUMBER_OF_BIDIR_DUAL_PORT_SLICES()	=	 BDP_DONT_SPLIT() ?  1 : ((USED(byteena_a) # USED(byteena_b)) & !BDP_SPECIAL_BYTEENA() ? DUAL_PORT_WIDTH_BYTEENA() : DUAL_PORT_WIDTH());
DEFINE BDP_BYTE_POSITION(i,j)				=	 i * BYTE_SIZE + FLOOR(j / BYTE_SIZE) * NUMBER_OF_BIDIR_DUAL_PORT_SLICES() * BYTE_SIZE + j MOD BYTE_SIZE;

-- number of segments()
DEFINE BIDIR_DUAL_PORT_MAX_DEPTH_BIT()		=	 RAM_BLOCK_TYPE() == "MEDIUM" ?  4096 : (RAM_BLOCK_TYPE() == "LARGE" ? 65536 : BDP_AUTO_MAX_DEPTH_BIT());
DEFINE BIDIR_DUAL_PORT_ADDRESS_SIZE_BIT()	=	 RAM_BLOCK_TYPE() == "MEDIUM" ?  12 : (RAM_BLOCK_TYPE() == "LARGE" ? 16 : BDP_AUTO_ADDRESS_SIZE_BIT());
DEFINE BIDIR_DUAL_PORT_MAX_DEPTH_BYTE()		=	 RAM_BLOCK_TYPE() == "MEDIUM" ?  512 : (RAM_BLOCK_TYPE() == "LARGE" ? (!USED(byteena_b)& ((WIDTH_A != WIDTH_B) # ((WIDTH_A == WIDTH_B) & !USED(byteena_a))) ? 65536 : 65536) : BDP_AUTO_MAX_DEPTH_BYTE());
DEFINE BIDIR_DUAL_PORT_ADDRESS_SIZE_BYTE()	=	 RAM_BLOCK_TYPE() == "MEDIUM" ?  9 : (RAM_BLOCK_TYPE() == "LARGE" ? (!USED(byteena_b)& ((WIDTH_A != WIDTH_B) # ((WIDTH_A == WIDTH_B) & !USED(byteena_a))) ? 16 : 16) : BDP_AUTO_ADDRESS_SIZE_BYTE());
DEFINE BIDIR_DUAL_PORT_MAX_DEPTH()			=	 !USED(byteena_a) & !USED(byteena_b) # BDP_SPECIAL_BYTEENA() ? BIDIR_DUAL_PORT_MAX_DEPTH_BIT() : BIDIR_DUAL_PORT_MAX_DEPTH_BYTE();
DEFINE MAX_DEPTH_BDP_NO_MAX()				=	 BIDIR_DUAL_PORT_MAX_DEPTH() > DUAL_PORT_LARGER_PORT_DEPTH() ? DUAL_PORT_LARGER_PORT_DEPTH() : BIDIR_DUAL_PORT_MAX_DEPTH();
DEFINE MAX_DEPTH_BDP_MAX()					=	 MAX_DEPTH_BDP_NO_MAX() > MAXIMUM_DEPTH	?  MAXIMUM_DEPTH : MAX_DEPTH_BDP_NO_MAX();
DEFINE MAXIMUM_DEPTH_BIDIR_DUAL_PORT()		=	 MAXIMUM_DEPTH == 0 ? MAX_DEPTH_BDP_NO_MAX() : MAX_DEPTH_BDP_MAX();
DEFINE BDP_SEGMENTS()						=	 WIDTH_A > WIDTH_B ? CEIL(NUM_WORDS_B /  MAXIMUM_DEPTH_BIDIR_DUAL_PORT()) : CEIL(NUM_WORDS_A / MAXIMUM_DEPTH_BIDIR_DUAL_PORT());
DEFINE NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()	=	 BDP_DONT_SPLIT() ? BDP_DONT_SPLIT_SEGMENTS() : BDP_SEGMENTS();
DEFINE BDP_DONT_SPLIT_SEGMENTS()			=	 CEIL (NUM_WORDS_A / 256);

--interleave bits
DEFINE BDP_DATA_INTERLEAVE_WIDTH()			=	 MIXED_MODE() ? (NUMBER_OF_BIDIR_DUAL_PORT_SLICES() == 1 ? 1 : BDP_SPECIAL_BYTEENA() ? 1 : (USED(byteena_a) # USED(byteena_b) ? BYTE_SIZE : 1)) : "UNUSED";
DEFINE BDP_DATA_INTERLEAVE_OFFSET()			=	 MIXED_MODE() ?  ((NUMBER_OF_BIDIR_DUAL_PORT_SLICES() == 1) ? 1 : BDP_SPECIAL_BYTEENA() ? NUMBER_OF_BIDIR_DUAL_PORT_SLICES() : (USED(byteena_a) # USED(byteena_b) ? NUMBER_OF_BIDIR_DUAL_PORT_SLICES()* BYTE_SIZE : NUMBER_OF_BIDIR_DUAL_PORT_SLICES())) : "UNUSED";

-- data width of slices
DEFINE BDP_PORT_A_DATA_WIDTH()				=	 BDP_DONT_SPLIT() ? WIDTH_A : (USED(byteena_a) # USED(byteena_b)) & !BDP_SPECIAL_BYTEENA() ? DP_A_WIDTH_BYTEENA() : DP_A_WIDTH();
DEFINE BDP_PORT_B_DATA_WIDTH()				=	 BDP_DONT_SPLIT() ? WIDTH_B : (USED(byteena_a) # USED(byteena_b)) & !BDP_SPECIAL_BYTEENA() ? DP_B_WIDTH_BYTEENA() : DP_B_WIDTH();

--first bit numbers
DEFINE BDP_PORT_A_FIRST_BIT_NUMBER(j)		=	 !MIXED_MODE() ? ((USED(byteena_a) # USED(byteena_b)) & !BDP_SPECIAL_BYTEENA() ? j*BYTE_SIZE : j) : j*BDP_DATA_INTERLEAVE_WIDTH();
DEFINE BDP_PORT_B_FIRST_BIT_NUMBER(j)		=	 !MIXED_MODE() ? ((USED(byteena_a) # USED(byteena_b)) & !BDP_SPECIAL_BYTEENA() ? j*BYTE_SIZE : j) : j*BDP_DATA_INTERLEAVE_WIDTH();

-- first address
DEFINE MAX_DEPTH_BDP_A()					=	 BDP_DONT_SPLIT() ? 256 :((WIDTH_A > WIDTH_B) ? MAXIMUM_DEPTH_BIDIR_DUAL_PORT() / (WIDTH_A / WIDTH_B) : MAXIMUM_DEPTH_BIDIR_DUAL_PORT());
DEFINE MAX_DEPTH_BDP_B()					=	 BDP_DONT_SPLIT() ? (256 * (WIDTH_A / WIDTH_B)) :((WIDTH_A > WIDTH_B) ? MAXIMUM_DEPTH_BIDIR_DUAL_PORT() : MAXIMUM_DEPTH_BIDIR_DUAL_PORT() / (WIDTH_B / WIDTH_A));
DEFINE BDP_PORT_A_FIRST_ADDRESS(i)			=	 (i == 0) ? 0 : i * MAX_DEPTH_BDP_A();	
DEFINE BDP_PORT_B_FIRST_ADDRESS(i)			=	 (i == 0) ? 0 : i * MAX_DEPTH_BDP_B();	

--last address
DEFINE BDP_PORT_A_LAST_ADDRESS(i)			=	 ((i+1) * MAX_DEPTH_BDP_A() - 1) > NUM_WORDS_A-1 ? NUM_WORDS_A-1 : (i+1) * MAX_DEPTH_BDP_A() - 1;
DEFINE BDP_PORT_B_LAST_ADDRESS(i)			=	 ((i+1) * MAX_DEPTH_BDP_B() - 1) > NUM_WORDS_B-1 ? NUM_WORDS_B-1 : (i+1) * MAX_DEPTH_BDP_B() - 1;

--decode, mux macros
DEFINE BIDIR_DUAL_PORT_ADDRESS_SIZE()		=	 BDP_DONT_SPLIT() ?  8 : CEIL(LOG2(MAXIMUM_DEPTH_BIDIR_DUAL_PORT()));
DEFINE BIDIR_DUAL_PORT_ADDRESS_SIZE_A()		=	 BDP_DONT_SPLIT() ? BIDIR_DUAL_PORT_ADDRESS_SIZE() : (WIDTHAD_A > WIDTHAD_B ? BIDIR_DUAL_PORT_ADDRESS_SIZE() : BIDIR_DUAL_PORT_ADDRESS_SIZE() - (WIDTHAD_B - WIDTHAD_A));
DEFINE BIDIR_DUAL_PORT_ADDRESS_SIZE_B()		=	 BDP_DONT_SPLIT() ? BIDIR_DUAL_PORT_ADDRESS_SIZE()+(WIDTHAD_B - WIDTHAD_A) : (WIDTHAD_B > WIDTHAD_A ? BIDIR_DUAL_PORT_ADDRESS_SIZE() : BIDIR_DUAL_PORT_ADDRESS_SIZE() - (WIDTHAD_A - WIDTHAD_B));
DEFINE BDP_UPPER_ADDRESS_A()				=	 WIDTHAD_A - BIDIR_DUAL_PORT_ADDRESS_SIZE_A();
DEFINE BDP_UPPER_ADDRESS_B()				=	 WIDTHAD_B - BIDIR_DUAL_PORT_ADDRESS_SIZE_B();

DEFINE BIDIR_DUAL_PORT_LAST_SEGMENT_DEPTH_A()	=	 BDP_DONT_SPLIT() ? (NUM_WORDS_A - MAX_DEPTH_BDP_A()*(NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1)) : (WIDTH_A > WIDTH_B ? (NUM_WORDS_B - ((NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_BIDIR_DUAL_PORT())) / (WIDTH_A / WIDTH_B) : NUM_WORDS_A - ((NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_BIDIR_DUAL_PORT()));
DEFINE BIDIR_DUAL_PORT_LAST_SEGMENT_ADDRESS_A()	=	 BIDIR_DUAL_PORT_LAST_SEGMENT_DEPTH_A() == 1 ? 1 : CEIL(LOG2(BIDIR_DUAL_PORT_LAST_SEGMENT_DEPTH_A()));
DEFINE BIDIR_DUAL_PORT_LAST_SEGMENT_DEPTH_B()	=	 BDP_DONT_SPLIT() ? (NUM_WORDS_B - MAX_DEPTH_BDP_B()*(NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1)) : (WIDTH_B > WIDTH_A ? (NUM_WORDS_A - ((NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_BIDIR_DUAL_PORT())) / (WIDTH_B / WIDTH_A) : NUM_WORDS_B - ((NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1) * MAXIMUM_DEPTH_BIDIR_DUAL_PORT()));
DEFINE BIDIR_DUAL_PORT_LAST_SEGMENT_ADDRESS_B()	=	 BIDIR_DUAL_PORT_LAST_SEGMENT_DEPTH_B() == 1 ? 1 : CEIL(LOG2(BIDIR_DUAL_PORT_LAST_SEGMENT_DEPTH_B()));

DEFINE SAME_CLEAR_USED()		=	ADDRESS_ACLR_B != "NONE" ? (CLEAR_CHECK(WRCONTROL_ACLR_B,ADDRESS_ACLR_B) & CLEAR_CHECK(INDATA_ACLR_B,ADDRESS_ACLR_B) & ((USED(byteena_b) & CLEAR_CHECK(BYTEENA_ACLR_B,ADDRESS_ACLR_B)) # !USED(byteena_b))) : SAME_CLEAR_USED_1();
DEFINE SAME_CLEAR_USED_1()		=	WRCONTROL_ACLR_B != "NONE" ? (CLEAR_CHECK(INDATA_ACLR_B,WRCONTROL_ACLR_B) & ((USED(byteena_b) & CLEAR_CHECK(BYTEENA_ACLR_B,WRCONTROL_ACLR_B)) # !USED(byteena_b))) : SAME_CLEAR_USED_2();
DEFINE SAME_CLEAR_USED_2()		=	INDATA_ACLR_B != "NONE" ? (((USED(byteena_b) & CLEAR_CHECK(BYTEENA_ACLR_B,INDATA_ACLR_B)) # !USED(byteena_b))) : 1;
DEFINE CLEAR_CHECK(X, Y)		=	(X == Y) # (X == "NONE");


DEFINE BDP_DEPTH_CHECK(X)						=	 RAM_BLOCK_TYPE() == "MEDIUM" ? (X > 256) : (RAM_BLOCK_TYPE() == "LARGE" ? (X > 32768) : (BDP_CHOOSE_LARGE() == "LARGE" ? (RATIO() == 1 ? X > 256 :  0) : X > 256));
DEFINE BDP_SPECIAL_BYTEENA()					=	 (WIDTH_A < WIDTH_B) ? (USED(byteena_a) & BDP_DEPTH_CHECK(NUM_WORDS_A)) :( (WIDTH_B < WIDTH_A) ? (USED(byteena_b) & BDP_DEPTH_CHECK(NUM_WORDS_B)) : ((USED(byteena_a) # USED(byteena_b)) & BDP_DEPTH_CHECK(NUM_WORDS_A)) );
DEFINE BDP_MRAM_SPECIAL_BYTEENA_PORT_B() 				=  RAM_BLOCK_TYPE() == "LARGE" # (RAM_BLOCK_TYPE() == "AUTO" & BDP_CHOOSE_LARGE() == "LARGE")  ? ((NUM_WORDS_B > 32768) & USED(byteena_b)) : 0;
DEFINE BDP_MRAM_SPECIAL_BYTEENA_PORT_A() 				=  RAM_BLOCK_TYPE() == "LARGE" # (RAM_BLOCK_TYPE() == "AUTO" & BDP_CHOOSE_LARGE() == "LARGE")  ? (WIDTH_A == WIDTH_B ? (NUM_WORDS_A > 32768) & USED(byteena_a) : 0) : 0;
--end bidir dual port defines

-- swap bidir dual code if needed
DEFINE SWAP_NEEDED()		=	WIDTH_B > WIDTH_A;
DEFINE SWAP_CLOCK0()		=	(ADDRESS_REG_B == "CLOCK1" ? "CLOCK1" : "CLOCK0");
DEFINE SWAP_CLOCK1()		=	SWAP_CLOCK0() == "CLOCK1" ? "CLOCK0" : (USED(clock1) ? "CLOCK1" : "NONE");
DEFINE SWAP_CLEAR0()		=	INPUT_CLEAR() == "CLEAR1" ? "CLEAR1" : (USED(aclr0) ? "CLEAR0" : "NONE");
DEFINE SWAP_CLEAR1()		=	SWAP_CLEAR0() == "CLEAR1" ? (USED(aclr0) ? "CLEAR0" : "NONE") : (USED(aclr1) ? "CLEAR1" : "NONE");
DEFINE INPUT_CLEAR()		=	ADDRESS_ACLR_B != "NONE" ? ADDRESS_ACLR_B : INPUT_CLEAR_1();
DEFINE INPUT_CLEAR_1()		=	WRCONTROL_ACLR_B != "NONE" ? WRCONTROL_ACLR_B : INPUT_CLEAR_2();
DEFINE INPUT_CLEAR_2()		=	INDATA_ACLR_B != "NONE" ? INDATA_ACLR_B : INPUT_CLEAR_3();
DEFINE INPUT_CLEAR_3()		=	USED(byteena_b) ? (BYTEENA_ACLR_B != "NONE" ? BYTEENA_ACLR_B : "NONE") : "NONE";

DEFINE CONVERT_CLOCK()		=	SWAP_CLOCK0() == "CLOCK1" ? "CLOCK1" : "CLOCK0";
DEFINE SWP_OUTDATA_REG_A()	=	OUTDATA_REG_A == "UNREGISTERED" ? "UNREGISTERED" : (OUTDATA_REG_A == SWAP_CLOCK0() ? "CLOCK0" : "CLOCK1");
DEFINE SWP_OUTDATA_REG_B()	=	OUTDATA_REG_B == "UNREGISTERED" ? "UNREGISTERED" : (OUTDATA_REG_B == SWAP_CLOCK0() ? "CLOCK0" : "CLOCK1");
DEFINE SWP_CHECK_CLEAR(X)	=	X == "NONE" ? "NONE" : (X == SWAP_CLEAR0() ? "CLEAR0" : "CLEAR1");
DEFINE SWP_MIF_FORMAT()		=	USED(INIT_FILE_LAYOUT) ? (INIT_FILE_LAYOUT == "PORT_A" ? "PORT_B" : "PORT_A") : "PORT_B";

-- other famlily macros
DEFINE USE_ROM_CLEAR()				=	ADDRESS_ACLR_A == "NONE" & OUTDATA_ACLR_A == "NONE";
DEFINE VALID_ROM_MODE()				=	USE_ROM_CLEAR() & ROM_MODE() & USED(INIT_FILE) & !USED(clocken0) & (USED(clock1) & !USED(clocken1) # !USED(clock1));
DEFINE USE_SINGLE_PORT_CLEAR()		=	ADDRESS_ACLR_A == "NONE" & WRCONTROL_ACLR_A == "NONE" & INDATA_ACLR_A == "NONE" & OUTDATA_ACLR_A == "NONE";
DEFINE VALID_SINGLE_PORT_MODE()		=	USE_SINGLE_PORT_CLEAR() & SINGLE_PORT_MODE() & !USED(byteena_a) & !USED(clocken0) & (USED(clock1) & !USED(clocken1) # !USED(clock1));

DEFINE CLEAR0_CNT()					=	USED(aclr0) ? 1 : 0;
DEFINE CLEAR1_CNT()					=	USED(aclr1) ? 1 : 0;
DEFINE USE_DP_CLEAR()				=	CLEAR0_CNT() + CLEAR1_CNT();
DEFINE VALID_DUAL_PORT_MODE()		=	USE_DP_CLEAR() <= 1 & WIDTH_A == WIDTH_B & !USED(byteena_a) & DP_OUT_REG_VALID() & DUAL_PORT_MODE();
DEFINE DP_ACLR(X) 					=	X == "NONE" ? "OFF" : "ON";
DEFINE DP_REG(X)					=	X == "CLOCK0" ? "INCLOCK" : (X == "CLOCK1" ? "OUTCLOCK" : "UNREGISTERED");
DEFINE DP_OUT_REG_VALID()			=	OUTDATA_REG_B != "UNREGISTERED" ? DP_REG(ADDRESS_REG_B) == "OUTCLOCK" & OUTDATA_REG_B == "CLOCK1" # DP_REG(ADDRESS_REG_B) == "INCLOCK" : 1;
DEFINE DP_OUT_REG()					=	OUTDATA_REG_B != "UNREGISTERED" ? "OUTCLOCK" : "UNREGISTERED";

-- mercury and apex II family macros
DEFINE QP_A_REG(X)				=	X == "CLOCK0" ? "INCLOCK_A" : (X == "CLOCK1" ? "OUTCLOCK_A" : "UNREGISTERED");
DEFINE QP_A_ACLR(X)				=	X == "CLEAR0" ? "INACLR_A" : (X == "CLEAR1" ? "OUTACLR_A" : "NONE");
DEFINE INCLOCK_B()				=	WRCONTROL_WRADDRESS_REG_B;
DEFINE QP_B_REG(X) 				=	X != "UNREGISTERED" ? (X == INCLOCK_B() ? "INCLOCK_B" : "OUTCLOCK_B") : "UNREGISTERED";
DEFINE INACLR_B()				=	(ADDRESS_ACLR_B != "NONE" ? ADDRESS_ACLR_B : (WRCONTROL_ACLR_B != "NONE" ? WRCONTROL_ACLR_B : (INDATA_ACLR_B != "NONE" ? INDATA_ACLR_B : OUTDATA_ACLR_B)));
DEFINE QP_B_ACLR(X)				=	X != "NONE" ? (X == INACLR_B() ? "INACLR_B" : "OUTACLR_B") : "NONE";

DEFINE CBX_ONLY_FAMILY()		=	((FAMILY_CYCLONEII() == 1) # (FAMILY_STRATIXII() == 1)) ? 1 :0;

SUBDESIGN altsyncram
(
	wren_a										: INPUT = GND;
	rden_a										: INPUT = VCC;
	wren_b										: INPUT = GND;
	rden_b										: INPUT = VCC;
	data_a[WIDTH_A - 1..0]						: INPUT = VCC;
	data_b[WIDTH_B - 1..0]						: INPUT = VCC;
	address_a[WIDTHAD_A - 1..0]					: INPUT;
	address_b[WIDTHAD_B - 1..0]					: INPUT = VCC;
	addressstall_a								: INPUT = GND;
	addressstall_b								: INPUT = GND;
	--two clocks only
	clock0										: INPUT = VCC;
	clock1										: INPUT = VCC;
	clocken0									: INPUT = VCC;
	clocken1									: INPUT = VCC;
	clocken2									: INPUT = VCC;
	clocken3									: INPUT = VCC;
	aclr0										: INPUT = GND;
	aclr1										: INPUT = GND;
	byteena_a[WIDTH_BYTEENA_A-1..0]				: INPUT = VCC;
	byteena_b[WIDTH_BYTEENA_B-1..0]				: INPUT = VCC;

	q_a[WIDTH_A - 1..0]					: OUTPUT;
	q_b[WIDTH_B - 1..0]					: OUTPUT;
	eccstatus[WIDTH_ECCSTATUS-1..0]						: OUTPUT;
)

VARIABLE
	IF (CBXI_PARAMETER == "NOTHING" & CBX_ONLY_FAMILY() == 0) GENERATE
		IF FAMILY_STRATIX() == 1 GENERATE
		IF ROM_MODE() GENERATE	
			ram_block[NUMBER_OF_ROM_SEGMENTS()-1..0][NUMBER_OF_ROM_SLICES()-1..0]	:	
				FOR i IN NUMBER_OF_ROM_SEGMENTS()-1 TO 0 GENERATE
					FOR j IN NUMBER_OF_ROM_SLICES()-1 TO 0 GENERATE
						stratix_ram_block WITH (
													OPERATION_MODE = "ROM",
													INIT_FILE = INTERNAL_FILE,
													RAM_BLOCK_TYPE = RAM_BLOCK_TYPE_WYS(),
													LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
													DATA_INTERLEAVE_OFFSET_IN_BITS = "UNUSED",
													DATA_INTERLEAVE_WIDTH_IN_BITS = "UNUSED",
													-- Port A parameters
													PORT_A_LOGICAL_RAM_DEPTH = NUM_WORDS_A,
													PORT_A_LOGICAL_RAM_WIDTH = WIDTH_A,
													PORT_A_ADDRESS_CLEAR = PORT_A_ADDRESS_CLEAR(),
													PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
													PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
													PORT_A_FIRST_ADDRESS = ROM_PORT_A_FIRST_ADDRESS(i),
													PORT_A_LAST_ADDRESS = ROM_PORT_A_LAST_ADDRESS(i),
													PORT_A_FIRST_BIT_NUMBER = j,
													PORT_A_DATA_WIDTH = 1,
													BYTE_SIZE_BLOCK = BYTE_SIZE,
													INIT_FILE_LAYOUT = USED(INIT_FILE_LAYOUT) ? INIT_FILE_LAYOUT : "PORT_A"
												)				
					END GENERATE
				END GENERATE;
				IF NUMBER_OF_ROM_SEGMENTS() > 1 GENERATE
					rom_mux :	lpm_mux WITH (
										LPM_WIDTH = WIDTH_A,
										LPM_SIZE = NUMBER_OF_ROM_SEGMENTS(),
										LPM_WIDTHS = CEIL(LOG2(NUMBER_OF_ROM_SEGMENTS()))
										);
						
					IF OUTPUT_A_REGISTERED() GENERATE
						rdaddress_buffer[1..0][ROM_UPPER_ADDRESS()-1..0]	:	DFFE;
					ELSE GENERATE
						rdaddress_buffer[ROM_UPPER_ADDRESS()-1..0]	: DFFE;
					END GENERATE;
				END GENERATE;
		END GENERATE; -- rom mode

		IF SINGLE_PORT_MODE() GENERATE
			ram_block[NUMBER_OF_SINGLE_PORT_SEGMENTS()-1..0][NUMBER_OF_SINGLE_PORT_SLICES()-1..0] :
				FOR i IN NUMBER_OF_SINGLE_PORT_SEGMENTS()-1 TO 0 GENERATE
					FOR j IN NUMBER_OF_SINGLE_PORT_SLICES()-1 TO 0 GENERATE
						stratix_ram_block WITH (
													OPERATION_MODE = "SINGLE_PORT",
													INIT_FILE = INTERNAL_FILE,
													RAM_BLOCK_TYPE = RAM_BLOCK_TYPE_WYS(),
													LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
													DATA_INTERLEAVE_OFFSET_IN_BITS = "UNUSED",
													DATA_INTERLEAVE_WIDTH_IN_BITS = "UNUSED",
													-- Port A parameters
													PORT_A_LOGICAL_RAM_DEPTH = NUM_WORDS_A,
													PORT_A_LOGICAL_RAM_WIDTH = WIDTH_A,
													PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
													PORT_A_ADDRESS_CLEAR = PORT_A_ADDRESS_CLEAR(),
													PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
													PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
													PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
													PORT_A_BYTE_ENABLE_CLEAR = PORT_A_BYTE_ENABLE_CLEAR(),												
													PORT_A_FIRST_ADDRESS = SP_PORT_A_FIRST_ADDRESS(i),
													PORT_A_LAST_ADDRESS = SP_PORT_A_LAST_ADDRESS(i),
													PORT_A_FIRST_BIT_NUMBER = SP_PORT_A_FIRST_BIT_NUMBER(j),
													PORT_A_DATA_WIDTH = SP_PORT_A_DATA_WIDTH(),
													BYTE_SIZE_BLOCK = BYTE_SIZE,
													INIT_FILE_LAYOUT = USED(INIT_FILE_LAYOUT) ? INIT_FILE_LAYOUT : "PORT_A"
													)				
					END GENERATE
				END GENERATE; 				
				IF NUMBER_OF_SINGLE_PORT_SEGMENTS() > 1 GENERATE
					sp_mux	 :	lpm_mux WITH (
										LPM_WIDTH = WIDTH_A,
										LPM_SIZE = NUMBER_OF_SINGLE_PORT_SEGMENTS(),
										LPM_WIDTHS = CEIL(LOG2(NUMBER_OF_SINGLE_PORT_SEGMENTS())));
					sp_decode :	lpm_decode WITH (
										LPM_WIDTH = WIDTHAD_A - SINGLE_PORT_ADDRESS_SIZE(),
										LPM_DECODES = 2^(WIDTHAD_A - SINGLE_PORT_ADDRESS_SIZE())	
										);
					IF OUTPUT_A_REGISTERED() GENERATE
						wraddress_buffer[1..0][SP_UPPER_ADDRESS()-1..0]	:	DFFE;
					ELSE GENERATE
						wraddress_buffer[SP_UPPER_ADDRESS()-1..0]	: DFFE;
					END GENERATE;
				END GENERATE;			
		END GENERATE;
		
		IF DUAL_PORT_MODE() GENERATE
			ram_block[NUMBER_OF_DUAL_PORT_SEGMENTS()-1..0][NUMBER_OF_DUAL_PORT_SLICES()-1..0]	:
				FOR	i IN NUMBER_OF_DUAL_PORT_SEGMENTS()-1 TO 0 GENERATE
					FOR j IN NUMBER_OF_DUAL_PORT_SLICES()-1 TO 0 GENERATE
						stratix_ram_block WITH (
													OPERATION_MODE = "DUAL_PORT",
													INIT_FILE = INTERNAL_FILE,
													RAM_BLOCK_TYPE = RAM_BLOCK_TYPE_WYS(),
													LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
													DATA_INTERLEAVE_OFFSET_IN_BITS = DP_DATA_INTERLEAVE_OFFSET(), 
													DATA_INTERLEAVE_WIDTH_IN_BITS = DP_DATA_INTERLEAVE_WIDTH(), 
													PORT_A_LOGICAL_RAM_DEPTH = NUM_WORDS_A,
													PORT_A_LOGICAL_RAM_WIDTH = WIDTH_A,
													PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
													PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
													PORT_A_ADDRESS_CLEAR = PORT_A_ADDRESS_CLEAR(),
													PORT_A_BYTE_ENABLE_CLEAR = PORT_A_BYTE_ENABLE_CLEAR(),
													PORT_A_FIRST_ADDRESS = DP_PORT_A_FIRST_ADDRESS(i),
													PORT_A_LAST_ADDRESS = DP_PORT_A_LAST_ADDRESS(i),
													PORT_A_FIRST_BIT_NUMBER = DP_PORT_A_FIRST_BIT_NUMBER(j),
													PORT_A_DATA_WIDTH = DP_PORT_A_DATA_WIDTH(),
													PORT_B_LOGICAL_RAM_DEPTH = NUM_WORDS_B,
													PORT_B_LOGICAL_RAM_WIDTH = WIDTH_B,
													PORT_B_ADDRESS_CLOCK = ADDRESS_REG_B,
													PORT_B_READ_ENABLE_WRITE_ENABLE_CLOCK = USED(rden_b) ? RDCONTROL_REG_B : ADDRESS_REG_B,
													PORT_B_READ_ENABLE_WRITE_ENABLE_CLEAR = USED(rden_b) ? RDCONTROL_ACLR_B : "NONE",
													PORT_B_ADDRESS_CLEAR = ADDRESS_ACLR_B,
													PORT_B_DATA_OUT_CLOCK = PORT_B_DATA_OUT_CLOCK(),
													PORT_B_DATA_OUT_CLEAR = PORT_B_DATA_OUT_CLEAR(),
													PORT_B_FIRST_ADDRESS = DP_PORT_B_FIRST_ADDRESS(i),
													PORT_B_LAST_ADDRESS = DP_PORT_B_LAST_ADDRESS(i),
													PORT_B_FIRST_BIT_NUMBER = DP_PORT_B_FIRST_BIT_NUMBER(j),
													PORT_B_DATA_WIDTH = DP_PORT_B_DATA_WIDTH(),
													MIXED_PORT_FEED_THROUGH_MODE = YGR_MIXED_PORT_FEED_THROUGH_MODE(),
													BYTE_SIZE_BLOCK = BYTE_SIZE,
													INIT_FILE_LAYOUT = USED(INIT_FILE_LAYOUT) ? INIT_FILE_LAYOUT : "PORT_B"
													)
					END GENERATE
				END GENERATE;	
				IF NUMBER_OF_DUAL_PORT_SEGMENTS() > 1 GENERATE
					dp_decode_a :	lpm_decode WITH (
										LPM_WIDTH = WIDTHAD_A - DUAL_PORT_ADDRESS_SIZE_A(),
										LPM_DECODES = 2^(WIDTHAD_A - DUAL_PORT_ADDRESS_SIZE_A())	
										);
					dp_mux_b	:	lpm_mux WITH (
										LPM_WIDTH = WIDTH_B,
										LPM_SIZE = NUMBER_OF_DUAL_PORT_SEGMENTS(),
										LPM_WIDTHS = CEIL(LOG2(NUMBER_OF_DUAL_PORT_SEGMENTS())));
	%				dp_decode_b :	lpm_decode WITH (
										LPM_WIDTH = WIDTHAD_B - DUAL_PORT_ADDRESS_SIZE_B(),
										LPM_DECODES = 2^(WIDTHAD_B - DUAL_PORT_ADDRESS_SIZE_B())	
										); %
					IF USED(rden_b) GENERATE
						address_latch	:	a_rdenreg WITH 
												(	WIDTH = DP_UPPER_ADDRESS(),
													D_ACLR = "NONE", --ADDRESS_ACLR_B == "NONE" ? "NONE" : "ACLR",
													E_ACLR = RDCONTROL_ACLR_B == "NONE" ? "NONE" : "ACLRE" --(RDCONTROL_ACLR_B == ADDRESS_ACLR_B ? "ACLR" : "ACLRE")
												);
						IF OUTPUT_B_REGISTERED() GENERATE
							address_buffer_b[DP_UPPER_ADDRESS()-1..0]	:	DFFE;
						END GENERATE; 
					ELSE GENERATE 
						IF OUTPUT_B_REGISTERED() GENERATE
							address_buffer_b[1..0][DP_UPPER_ADDRESS()-1..0]	:	DFFE;
						ELSE GENERATE
							address_buffer_b[DP_UPPER_ADDRESS()-1..0]	: DFFE;
						END GENERATE; 
					END GENERATE;
				END GENERATE;
		END GENERATE;
		
		IF BIDIR_DUAL_PORT_MODE() GENERATE
			IF SWAP_NEEDED() GENERATE
				new_ram	:	altsyncram WITH (
							OPERATION_MODE = OPERATION_MODE,
							WIDTH_A = WIDTH_B,
							WIDTHAD_A = WIDTHAD_B,
							NUMWORDS_A = NUMWORDS_B,
							INDATA_ACLR_A = SWP_CHECK_CLEAR(INDATA_ACLR_B),
							WRCONTROL_ACLR_A = SWP_CHECK_CLEAR(WRCONTROL_ACLR_B),
							ADDRESS_ACLR_A = SWP_CHECK_CLEAR(ADDRESS_ACLR_B),
							WIDTH_B = WIDTH_A,
							WIDTHAD_B = WIDTHAD_A,
							NUMWORDS_B = NUMWORDS_A,
							INDATA_REG_B = CONVERT_CLOCK(),
							INDATA_ACLR_B = SWP_CHECK_CLEAR(INDATA_ACLR_A),
							WRCONTROL_WRADDRESS_REG_B = CONVERT_CLOCK(),
							WRCONTROL_ACLR_B = SWP_CHECK_CLEAR(WRCONTROL_ACLR_A),
							ADDRESS_ACLR_B = SWP_CHECK_CLEAR(ADDRESS_ACLR_A),
							OUTDATA_REG_A = SWP_OUTDATA_REG_B(),
							OUTDATA_ACLR_A = SWP_CHECK_CLEAR(OUTDATA_ACLR_B),
							ADDRESS_REG_B = CONVERT_CLOCK(),
							OUTDATA_REG_B = SWP_OUTDATA_REG_A(),
							OUTDATA_ACLR_B = SWP_CHECK_CLEAR(OUTDATA_ACLR_A),
							BYTEENA_ACLR_A = SWP_CHECK_CLEAR(BYTEENA_ACLR_B),
							BYTEENA_ACLR_B = SWP_CHECK_CLEAR(BYTEENA_ACLR_A),
							BYTEENA_REG_B = CONVERT_CLOCK(),
							INIT_FILE = INIT_FILE,
							MAXIMUM_DEPTH = MAXIMUM_DEPTH,
							WIDTH_BYTEENA_A = WIDTH_BYTEENA_B,
							WIDTH_BYTEENA_B = WIDTH_BYTEENA_A,
							BYTE_SIZE = BYTE_SIZE,
							READ_DURING_WRITE_MIXED_PORTS = READ_DURING_WRITE_MODE_MIXED_PORTS,
							RAM_BLOCK_TYPE = RAM_BLOCK_TYPE,
							DEVICE_FAMILY = DEVICE_FAMILY,
							INIT_FILE_LAYOUT = SWP_MIF_FORMAT()
							);
					
			ELSE GENERATE
			ram_block[NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1..0][NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1..0]	:
				FOR	i IN NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 TO 0 GENERATE
					FOR j IN NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 TO 0 GENERATE
						stratix_ram_block WITH (
													OPERATION_MODE = "BIDIR_DUAL_PORT",
													INIT_FILE = INTERNAL_FILE,
													RAM_BLOCK_TYPE = RAM_BLOCK_TYPE_WYS(),
													LOGICAL_RAM_NAME = LOGICAL_RAM_NAME,
													DATA_INTERLEAVE_OFFSET_IN_BITS = BDP_DATA_INTERLEAVE_OFFSET(), 
													DATA_INTERLEAVE_WIDTH_IN_BITS = BDP_DATA_INTERLEAVE_WIDTH(), 
													PORT_A_LOGICAL_RAM_DEPTH = NUM_WORDS_A,
													PORT_A_LOGICAL_RAM_WIDTH = WIDTH_A,
													PORT_A_DATA_IN_CLEAR = PORT_A_DATA_IN_CLEAR(),
													PORT_A_WRITE_ENABLE_CLEAR = PORT_A_WRITE_ENABLE_CLEAR(),
													PORT_A_ADDRESS_CLEAR = PORT_A_ADDRESS_CLEAR(),
													PORT_A_DATA_OUT_CLOCK = PORT_A_DATA_OUT_CLOCK(),
													PORT_A_DATA_OUT_CLEAR = PORT_A_DATA_OUT_CLEAR(),
													PORT_A_BYTE_ENABLE_CLEAR = PORT_A_BYTE_ENABLE_CLEAR(),
													PORT_A_FIRST_ADDRESS = BDP_PORT_A_FIRST_ADDRESS(i),
													PORT_A_LAST_ADDRESS = BDP_PORT_A_LAST_ADDRESS(i),
													PORT_A_FIRST_BIT_NUMBER = BDP_PORT_A_FIRST_BIT_NUMBER(j),
													PORT_A_DATA_WIDTH = BDP_PORT_A_DATA_WIDTH(),
													PORT_B_LOGICAL_RAM_DEPTH = NUM_WORDS_B,
													PORT_B_LOGICAL_RAM_WIDTH = WIDTH_B,
													PORT_B_ADDRESS_CLOCK = ADDRESS_REG_B,
													PORT_B_DATA_IN_CLOCK = INDATA_REG_B,
													PORT_B_READ_ENABLE_WRITE_ENABLE_CLOCK = WRCONTROL_WRADDRESS_REG_B,
													PORT_B_READ_ENABLE_WRITE_ENABLE_CLEAR = WRCONTROL_ACLR_B,
													PORT_B_DATA_IN_CLEAR = INDATA_ACLR_B,
													PORT_B_ADDRESS_CLEAR = ADDRESS_ACLR_B,
													PORT_B_DATA_OUT_CLOCK = PORT_B_DATA_OUT_CLOCK(),
													PORT_B_DATA_OUT_CLEAR = PORT_B_DATA_OUT_CLEAR(),
													PORT_B_BYTE_ENABLE_CLOCK = PORT_B_BYTE_ENABLE_CLOCK(),
													PORT_B_BYTE_ENABLE_CLEAR = PORT_B_BYTE_ENABLE_CLEAR(),
													PORT_B_FIRST_ADDRESS = BDP_PORT_B_FIRST_ADDRESS(i),
													PORT_B_LAST_ADDRESS = BDP_PORT_B_LAST_ADDRESS(i),
													PORT_B_FIRST_BIT_NUMBER = BDP_PORT_B_FIRST_BIT_NUMBER(j),
													PORT_B_DATA_WIDTH = BDP_PORT_B_DATA_WIDTH(),
													MIXED_PORT_FEED_THROUGH_MODE = YGR_MIXED_PORT_FEED_THROUGH_MODE(),
													BYTE_SIZE_BLOCK = BYTE_SIZE,
													INIT_FILE_LAYOUT = USED(INIT_FILE_LAYOUT) ? INIT_FILE_LAYOUT : "PORT_A"
													)
					END GENERATE
				END GENERATE;	
				IF NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() > 1 GENERATE
					bdp_mux_a 	:	lpm_mux WITH (
										LPM_WIDTH = WIDTH_A,
										LPM_SIZE = NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS(),
										LPM_WIDTHS = CEIL(LOG2(NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()))
										);
					bdp_decode_a :	lpm_decode WITH (
										LPM_WIDTH = WIDTHAD_A - BIDIR_DUAL_PORT_ADDRESS_SIZE_A(),
										LPM_DECODES = 2^(WIDTHAD_A - BIDIR_DUAL_PORT_ADDRESS_SIZE_A())	
										);
					bdp_mux_b	:	lpm_mux WITH (
										LPM_WIDTH = WIDTH_B,
										LPM_SIZE = NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS(),
										LPM_WIDTHS = CEIL(LOG2(NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS())));
					bdp_decode_b :	lpm_decode WITH (
										LPM_WIDTH = WIDTHAD_B - BIDIR_DUAL_PORT_ADDRESS_SIZE_B(),
										LPM_DECODES = 2^(WIDTHAD_B - BIDIR_DUAL_PORT_ADDRESS_SIZE_B())	
										);
					IF OUTPUT_A_REGISTERED() GENERATE
						address_buffer_a[1..0][BDP_UPPER_ADDRESS_A()-1..0]	:	DFFE;
					ELSE GENERATE
						address_buffer_a[BDP_UPPER_ADDRESS_A()-1..0]	: DFFE;
					END GENERATE; 
					IF OUTPUT_B_REGISTERED() GENERATE
						address_buffer_b[1..0][BDP_UPPER_ADDRESS_B()-1..0]	:	DFFE;
					ELSE GENERATE
						address_buffer_b[BDP_UPPER_ADDRESS_B()-1..0]	: DFFE;
					END GENERATE; 
				END GENERATE;			
			END GENERATE;
		END GENERATE;
		ELSE GENERATE
			IF VALID_ROM_MODE() GENERATE
				rom : altrom WITH
						(	WIDTH = WIDTH_A,
							AD_WIDTH = WIDTHAD_A,
							NUMWORDS = NUM_WORDS_A,
							FILE = INTERNAL_FILE,
							REGISTERINPUTMODE = "ALL",
							MAXIMUM_DEPTH = MAXIMUM_DEPTH,
							DEVICE_FAMILY = DEVICE_FAMILY
						);
			END GENERATE;
			IF VALID_SINGLE_PORT_MODE() GENERATE
				spram : altram WITH
					(
						WIDTH = WIDTH_A,
						AD_WIDTH = WIDTHAD_A,
						NUMWORDS = NUM_WORDS_A,
						FILE = INTERNAL_FILE,
						REGISTERINPUTMODE = "ALL",
						MAXIMUM_DEPTH = MAXIMUM_DEPTH,
						DEVICE_FAMILY = DEVICE_FAMILY
					);
			END GENERATE;
			IF VALID_DUAL_PORT_MODE() GENERATE
				dpram : altdpram WITH
					(
						WIDTH  = WIDTH_A,
						WIDTHAD = WIDTHAD_A,
						NUMWORDS = NUM_WORDS_A,
						FILE = INIT_FILE,
						LPM_FILE = INIT_FILE,
						INDATA_REG = "INCLOCK",
						INDATA_ACLR = DP_ACLR(INDATA_ACLR_A),
						WRADDRESS_REG = "INCLOCK",
						WRADDRESS_ACLR = DP_ACLR(ADDRESS_ACLR_A),
						WRCONTROL_REG = "INCLOCK",
						WRCONTROL_ACLR = DP_ACLR(WRCONTROL_ACLR_A),
						RDADDRESS_REG = DP_REG(ADDRESS_REG_B),
						RDADDRESS_ACLR = DP_ACLR(ADDRESS_ACLR_B),
						RDCONTROL_REG = DP_REG(RDCONTROL_REG_B),
						RDCONTROL_ACLR = DP_ACLR(RDCONTROL_ACLR_B),
						OUTDATA_REG = DP_OUT_REG(),
						OUTDATA_ACLR = DP_ACLR(OUTDATA_ACLR_B),
						MAXIMUM_DEPTH = MAXIMUM_DEPTH,
						DEVICE_FAMILY = DEVICE_FAMILY
					);
			END GENERATE;
		END GENERATE;
	ELSE GENERATE
		IF (CBXI_PARAMETER != "NOTHING") GENERATE
			-- Go with the clearbox implementation
			auto_generated : @CBXI_PARAMETER WITH (CBXI_PARAMETER = "NOTHING");
		END GENERATE;
	END GENERATE;
BEGIN
	IF (ROM_MODE()) GENERATE
		ASSERT (WIDTHAD_A <= RAM_MAX_ADDRESS_WIDTH)
		REPORT " ROM for % device_family is too big to be implemented by altsyncram megafunction " DEVICE_FAMILY
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_TOO_BIG;
	ELSE GENERATE
		ASSERT (WIDTHAD_A <= RAM_MAX_ADDRESS_WIDTH)
		REPORT " % RAM for % device_family is too big to be implemented by altsyncram megafunction " OPERATION_MODE, DEVICE_FAMILY
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_TOO_BIG;
	END GENERATE;
	IF (DUAL_PORT_MODE()# BIDIR_DUAL_PORT_MODE()) GENERATE
		ASSERT (WIDTHAD_B <= RAM_MAX_ADDRESS_WIDTH)
		REPORT " % RAM for % device_family is too big to be implemented by altsyncram megafunction " OPERATION_MODE, DEVICE_FAMILY
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_TOO_BIG;
	END GENERATE;

	IF (CBXI_PARAMETER == "NOTHING" & CBX_ONLY_FAMILY() == 0) GENERATE
				
		IF ROM_MODE() GENERATE
			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altrom megafunctions because the altrom megafunction does not support absence of initialization file.
			--ACTION:	Use an Initiliazation file, and then compile again to allow the Quartus II software to attempt to implement the ROM in an altrom megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_ROM_MODE())# USED(INIT_FILE))
			REPORT " Can't implement ROM for % device family from altsyncram megafunction because INIT_FILE parameter is not specified" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_ROM_INIT_FILE;

			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altrom megafunctions because the altrom megafunction does not support aclr ports.
			--ACTION:	Remove or disconnect the aclr port, and then compile again to allow the Quartus II software to attempt to implement the ROM in an altrom megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_ROM_MODE())# FAMILY_STRATIX() # USE_ROM_CLEAR())	
			REPORT " Can't implement ROM for % device family from altsyncram megafunction because aclr ports are not supported in altrom megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_ROM_USE_ACLRS;

			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altrom megafunctions because the altrom megafunction does not support clock enable ports.
			--ACTION:	Remove or disconnect the clock enable port, and then compile again to allow the Quartus II software to attempt to implement the ROM in an altrom megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & VALID_ROM_MODE() # FAMILY_STRATIX() # !USED(clocken0) & (USED(clock1) & !USED(clocken1) # !USED(clock1)))	
			REPORT " Can't implement ROM for % device family from altsyncram megafunction because clock enable ports are not supported in altrom megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_ROM_USE_CLKEN;

		END GENERATE;
		
		IF SINGLE_PORT_MODE() GENERATE
			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altram megafunctions because the altram megafunction does not support byteena ports.
			--ACTION:	Remove or disconnect the byteena_a port, and then compile again to allow the Quartus II software to attempt to implement the single port RAM in an altram megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_SINGLE_PORT_MODE())# FAMILY_STRATIX() # !USED(byteena_a))	
			REPORT " Can't implement single port RAM for % device family from altsyncram megafunction because byte enable is not supported in altram megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_SP_BYTE_ENABLE;

			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altram megafunctions because the altram megafunction does not support aclr ports.
			--ACTION:	Remove or disconnect the aclr port, and then compile again to allow the Quartus II software to attempt to implement the single port RAM in an altram megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_SINGLE_PORT_MODE())# FAMILY_STRATIX() # USE_SINGLE_PORT_CLEAR())	
			REPORT " Can't implement single port RAM for % device family from altsyncram megafunction because aclr ports are not supported in altram megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_SP_USE_ACLRS;
		
			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altram megafunctions because the altram megafunction does not support clock enable ports.
			--ACTION:	Remove or disconnect the clock enable ports, and then compile again to allow the Quartus II software to attempt to implement the single port RAM in an altram megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & VALID_SINGLE_PORT_MODE() # FAMILY_STRATIX() # !USED(clocken0) & (USED(clock1) & !USED(clocken1) # !USED(clock1)))	
			REPORT " Can't implement single port RAM for % device family from altsyncram megafunction because clock enable ports are not supported in altram megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_SP_USE_CLKEN;
		END GENERATE;
		
		IF DUAL_PORT_MODE() GENERATE

			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altdpram megafunctions because the altdpram megafunction does not support mixed widths.
			--ACTION:	Change the widths of A and B ports to be the same, and then compile again to allow the Quartus II software to attempt to implement the dual port RAM in an altdpram megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_DUAL_PORT_MODE())# FAMILY_STRATIX() # (WIDTH_A == WIDTH_B))			
			REPORT " Can't implement dual-port RAM for % device family from altsyncram megafunction because mixed widths for read and write ports are not supported in altdpram megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_DP_USE_MIXED_WIDTHS;

			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altdpram megafunctions because the altdpram megafunction does not support multiple aclr ports
			--ACTION:	Remove or disconnect one or more aclr ports, and then compile again to allow the Quartus II software to attempt to implement the dual port RAM in an altdpram megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_DUAL_PORT_MODE())# FAMILY_STRATIX() # (USE_DP_CLEAR() <= 1 ))			
			REPORT " Can't implement dual-port RAM for % device family from altsyncram megafunction because multiple aclr ports are not supported in altdpram megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_DP_USE_MIXED_WIDTHS;

			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altdpram megafunctions because the altdpram megafunction does not support byte enable ports.
			--ACTION:	Remove byteena_a port, and then compile again to allow the Quartus II software to attempt to implement the dual port RAM in an altdpram megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_DUAL_PORT_MODE())# FAMILY_STRATIX() # !USED(byteena_a))	
			REPORT " Can't implement dual-port RAM for % device family from altsyncram megafunction because byte enable is not supported in altdpram megafunction" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_DP_BYTE_ENABLE;

			--CAUSE:	The design contains the altsyncram megafunction, but the selected device or device family is not the Stratix device family. The altsyncram megafunction is supported only for the Stratix device family. The Quartus II software is not able to convert the altsyncram megafunction implementations to altdpram megafunctions because the altdpram megafunction does not support the chosen clock combination.
			--ACTION:	Change the usage of clocks such that either the read and output clock are the same or read and write clocks are the same, and then compile again to allow the Quartus II software to attempt to implement the dual port RAM in an altdpram megafunction
			ASSERT ( FAMILY_STRATIX() != 1 & (VALID_DUAL_PORT_MODE())# FAMILY_STRATIX() # DP_OUT_REG_VALID())	
			REPORT " Can't implement dual port RAM for % device family from altsyncram megafunction because the chosen clock combination is not supported in altdpram megafunction. Output data clock has to be the same as read clock or read clock has to be the same as write clock" DEVICE_FAMILY
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_CONVERT_DP_INVALID_CLK_COMB;

		END GENERATE;

		--CAUSE:	WIDTH_BYTEENA_A parameter is set to either 1 or 0, but the byteena_a port is connected
		--ACTION:	Remove byteena_a port or set WIDTH_BYTEENA_A to WIDTH_A / BYTE_SIZE.	
		ASSERT (WIDTH_BYTEENA_A <= 1 & !USED(byteena_a) # WIDTH_BYTEENA_A > 1)
		REPORT "byteena_a port can't be used when WIDTH_BYTEENA_A parameter is <= 1"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_WBENA_INVALID;

		--CAUSE:	WIDTH_BYTEENA_B parameter is set to either 1 or 0, but the byteena_b port is connected
		--ACTION:	Remove byteena_b port or set WIDTH_BYTEENA_B to WIDTH_B / BYTE_SIZE.	
		ASSERT (WIDTH_BYTEENA_B <= 1 & !USED(byteena_b) # WIDTH_BYTEENA_B > 1)
		REPORT "byteena_b port can't be used when WIDTH_BYTEENA_B parameter is <= 1"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_WBENB_INVALID;
		
		ASSERT (ROM_MODE() # SINGLE_PORT_MODE() # DUAL_PORT_MODE() # BIDIR_DUAL_PORT_MODE())
		REPORT "% is not a valid operation mode" OPERATION_MODE
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_MODE;

		ASSERT (USED(clock0))
		REPORT "Clock0 port should always be connected"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_CLOCK_UNCONNECTED;
		
		ASSERT ((RAM_BLOCK_TYPE() == "LARGE" & !USED(INIT_FILE)) # RAM_BLOCK_TYPE() != "LARGE")
		REPORT "M-RAM block type doesn't support the use of an initialization file"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_MRAM_NO_INIT_FILE;
		
		ASSERT (FAMILY_STRATIX() == 1 # DUAL_PORT_MODE() # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "altsyncram megafunction doesn't support % device family in % operation mode" DEVICE_FAMILY, OPERATION_MODE
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_WRONG_FAMILY;
		
		ASSERT ((RAM_BLOCK_TYPE() == "SMALL" & !USED(byteena_a) & !USED(byteena_b)) # (RAM_BLOCK_TYPE() != "SMALL"))
		REPORT "M512 block type doesn't support the use of byte enable ports"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_SEAB_NO_BYTEENABLE;
		
		
		ASSERT ((RAM_BLOCK_TYPE() == "LARGE" & (READ_DURING_WRITE_MODE_MIXED_PORTS != "OLD_DATA" # !USED(READ_DURING_WRITE_MODE_MIXED_PORTS))) # RAM_BLOCK_TYPE() != "LARGE")
		REPORT "M-RAM doesn't support OLD_DATA value for READ_DURING_WRITE_MODE_MIXED_PORTS parameter"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_MRAM_NO_OLD_DATA_MIXED_FEED_THRU;
		
		-- checking validity of ports connected
		ASSERT (USED(clock1) & USED(clocken1) # !USED(clock1) & !USED(clocken1) # !USED(clocken1))
		REPORT "Can't connect clocken1 port when clock1 port is not connected"
		SEVERITY WARNING
		HELP_ID ALTSYNCRAM_INVALID_CLKEN1;

		-- checking validity of parameters
		ASSERT (OUTDATA_REG_A == "CLOCK0" # OUTDATA_REG_A == "CLOCK1" # OUTDATA_REG_A == "UNREGISTERED" # !USED(OUTDATA_REG_A) # DUAL_PORT_MODE())
		REPORT "INVALID VALUE FOR PARAMETER OUTDATA_REG_A, HAS TO BE EITHER CLOCK0, CLOCK1 or UNREGISTERED"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_OUTDATA_REG_A;
			
		ASSERT (OUTDATA_REG_B == "CLOCK0" # OUTDATA_REG_B == "CLOCK1" # OUTDATA_REG_B == "UNREGISTERED" # !USED(OUTDATA_REG_B) # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "INVALID VALUE FOR PARAMETER OUTDATA_REG_B, HAS TO BE EITHER CLOCK0, CLOCK1 or UNREGISTERED"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_OUTDATA_REG_B;

		ASSERT (ADDRESS_REG_B == "CLOCK0" # ADDRESS_REG_B == "CLOCK1" # ADDRESS_REG_B == "UNREGISTERED" # !USED(ADDRESS_REG_B) # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "INVALID VALUE FOR PARAMETER ADDRESS_REG_B, HAS TO BE EITHER CLOCK0, CLOCK1 or UNREGISTERED"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_ADDRESS_REG_B;

		ASSERT (RDCONTROL_REG_B == "CLOCK0" # RDCONTROL_REG_B == "CLOCK1" # RDCONTROL_REG_B == "UNREGISTERED" # !USED(RDCONTROL_REG_B) # ROM_MODE() # SINGLE_PORT_MODE() # BIDIR_DUAL_PORT_MODE())
		REPORT "INVALID VALUE FOR PARAMETER RDCONTROL_REG_B, HAS TO BE EITHER CLOCK0, CLOCK1 or UNREGISTERED"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_RDCONTROL_REG_B;

		ASSERT (WRCONTROL_WRADDRESS_REG_B == "CLOCK0" # WRCONTROL_WRADDRESS_REG_B == "CLOCK1" # WRCONTROL_WRADDRESS_REG_B == "UNREGISTERED" # !USED(WRCONTROL_WRADDRESS_REG_B) # ROM_MODE() # SINGLE_PORT_MODE() # DUAL_PORT_MODE())
		REPORT "INVALID VALUE FOR PARAMETER WRCONTROL_WRADDRESS_REG_B, HAS TO BE EITHER CLOCK0, CLOCK1 or UNREGISTERED"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_WRCONTROL_WRADDRESS_REG_B;

		ASSERT (BYTEENA_REG_B == "CLOCK0" # BYTEENA_REG_B == "CLOCK1" # BYTEENA_REG_B == "UNREGISTERED" # !USED(BYTEENA_REG_B) # !USED(byteena_b))
		REPORT "INVALID VALUE FOR PARAMETER BYTEENA_REG_B, HAS TO BE EITHER CLOCK0, CLOCK1 or UNREGISTERED"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_BYTEENA_REG_B;

		ASSERT (INDATA_ACLR_A == "CLEAR0" # INDATA_ACLR_A == "NONE" # !USED(INDATA_ACLR_A) # ROM_MODE())
		REPORT "INVALID VALUE FOR INDATA_ACLR_A, HAS TO BE EITHER CLEAR0 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_INDATA_ACLR_A;

		ASSERT (ADDRESS_ACLR_A == "CLEAR0" # ADDRESS_ACLR_A == "NONE" # !USED(ADDRESS_ACLR_A))
		REPORT "INVALID VALUE FOR ADDRESS_ACLR_A, HAS TO BE EITHER CLEAR0 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_ADDRESS_ACLR_A;

		ASSERT (WRCONTROL_ACLR_A == "CLEAR0" # WRCONTROL_ACLR_A == "NONE" # !USED(WRCONTROL_ACLR_A) # ROM_MODE())
		REPORT "INVALID VALUE FOR WRCONTROL_ACLR_A, HAS TO BE EITHER CLEAR0 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_WRCONTROL_ACLR_A;

		ASSERT (BYTEENA_ACLR_A == "CLEAR0" # BYTEENA_ACLR_A == "NONE" # !USED(BYTEENA_ACLR_A) # !USED(byteena_a))
		REPORT "INVALID VALUE FOR BYTEENA_ACLR_A, HAS TO BE EITHER CLEAR0 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_BYTEENA_ACLR_A;

		ASSERT (OUTDATA_ACLR_A == "CLEAR0" # OUTDATA_ACLR_A == "CLEAR1" # OUTDATA_ACLR_A == "NONE" # !USED(OUTDATA_ACLR_A) # DUAL_PORT_MODE())
		REPORT "INVALID VALUE FOR OUTDATA_ACLR_A, HAS TO BE EITHER CLEAR0, CLEAR1 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_OUTDATA_ACLR_A;

		ASSERT (INDATA_ACLR_B == "CLEAR0" # INDATA_ACLR_B == "CLEAR1" # INDATA_ACLR_B == "NONE" # !USED(INDATA_ACLR_B) # ROM_MODE() # SINGLE_PORT_MODE() # DUAL_PORT_MODE())
		REPORT "INVALID VALUE FOR INDATA_ACLR_B, HAS TO BE EITHER CLEAR0, CLEAR1 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_INDATA_ACLR_B;

		ASSERT (WRCONTROL_ACLR_B == "CLEAR0" # WRCONTROL_ACLR_B == "CLEAR1" # WRCONTROL_ACLR_B == "NONE" # !USED(WRCONTROL_ACLR_B) # ROM_MODE() # SINGLE_PORT_MODE() # DUAL_PORT_MODE())
		REPORT "INVALID VALUE FOR WRCONTROL_ACLR_B, HAS TO BE EITHER CLEAR0, CLEAR1 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_WRCONTROL_INDATA_ACLR_B;

		ASSERT (RDCONTROL_ACLR_B == "CLEAR0" # RDCONTROL_ACLR_B == "CLEAR1" # RDCONTROL_ACLR_B == "NONE" # !USED(RDCONTROL_ACLR_B) # ROM_MODE() # SINGLE_PORT_MODE() # BIDIR_DUAL_PORT_MODE())
		REPORT "INVALID VALUE FOR RDCONTROL_ACLR_B, HAS TO BE EITHER CLEAR0, CLEAR1 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_RDCONTROL_ACLR_B;

		ASSERT (ADDRESS_ACLR_B == "CLEAR0" # ADDRESS_ACLR_B == "CLEAR1" # ADDRESS_ACLR_B == "NONE" # !USED(ADDRESS_ACLR_B) # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "INVALID VALUE FOR ADDRESS_ACLR_B, HAS TO BE EITHER CLEAR0, CLEAR1 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_ADDRESS_ACLR_B;

		ASSERT (BYTEENA_ACLR_B == "CLEAR0" # BYTEENA_ACLR_B == "CLEAR1" # BYTEENA_ACLR_B == "NONE" # !USED(BYTEENA_ACLR_B) # !USED(byteena_b))
		REPORT "INVALID VALUE FOR BYTEENA_ACLR_B, HAS TO BE EITHER CLEAR0, CLEAR1 or NONE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_BYTEENA_ACLR_B;

		IF USED(byteena_a) GENERATE
			ASSERT (USED(byteena_a) & WIDTH_BYTEENA_A == WIDTH_A / BYTE_SIZE # !USED(byteena_a))
			REPORT "WIDTH_BYTEENA_A PARAMETER NOT PROPERLY SET. IT HAS TO BE WIDTH_A / BYTE_SIZE WHEN BYTEENA_A PORT IS USED"
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_INVALID_WIDTH_BYTEENA_A;
		END GENERATE;

		IF USED(byteena_b) GENERATE
			ASSERT (USED(byteena_b) & WIDTH_BYTEENA_B == WIDTH_B / BYTE_SIZE # !USED(byteena_b))
			REPORT "WIDTH_BYTEENA_B PARAMETER NOT PROPERLY SET. IT HAS TO BE WIDTH_B / BYTE_SIZE WHEN BYTEENA_B PORT IS USED"
			SEVERITY ERROR
			HELP_ID ALTSYNCRAM_INVALID_WIDTH_BYTEENA_B;
		END GENERATE;

		ASSERT (BYTE_SIZE == 8 # BYTE_SIZE == 9)
		REPORT "BYTE SIZE HAS TO BE EITHER 8 or 9"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_BYTE_SIZE;
		
		ASSERT (RAM_BLOCK_TYPE() == "SMALL" # RAM_BLOCK_TYPE() == "MEDIUM" # RAM_BLOCK_TYPE() == "LARGE" # RAM_BLOCK_TYPE() == "AUTO" # !USED(RAM_BLOCK_TYPE))
		REPORT "RAM_BLOCK_TYPE HAS AN INVALID VALUE. IT CAN ONLY BE M512, M4K, M-RAM OR AUTO"
		SEVERITY ERROR
		HELP_ID ALTSYCNRAM_INVALID_RAM_BLOCK_TYPE;
		
		ASSERT (READ_DURING_WRITE_MODE_MIXED_PORTS == "OLD_DATA" # READ_DURING_WRITE_MODE_MIXED_PORTS == "DONT_CARE" # !USED(READ_DURING_WRITE_MODE_MIXED_PORTS) # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "INVALID VALUE FOR READ_DURING_WRITE_MODE_MIXED_PORTS PARAMETER. IT HAS TO BE OLD_DATA OR DONT_CARE"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_MIXED_FEED_THRU;
		
		ASSERT (WIDTH_A > 0)
		REPORT "Invalid value for WIDTH_A parameter"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_WIDTH_A;
		
		ASSERT (WIDTH_B > 0 # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "Invalid value for WIDTH_B parameter"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_WIDTH_B;
		
		ASSERT (WIDTHAD_A > 0)
		REPORT "Invalid value for WIDTHAD_A parameter"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_WIDTHAD_A;
		
		ASSERT (WIDTHAD_B > 0 # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "Invalid value for WIDTHAD_B parameter"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_WIDTHAD_B;
		
		ASSERT (NUMWORDS_A >= 0 )
		REPORT "Invalid value for NUMWORDS_A parameter"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_NUMWORDS_A;
		
		ASSERT (NUMWORDS_B >= 0 # ROM_MODE() # SINGLE_PORT_MODE())
		REPORT "Invalid value for NUMWORDS_B parameter"
		SEVERITY ERROR
		HELP_ID ALTSYNCRAM_INVALID_NUMWORDS_B;
		
		
		-- rom mode asserts
		IF ROM_MODE() GENERATE
		ASSERT (ROM_MODE() & RAM_BLOCK_TYPE() != "LARGE")
		REPORT "M-RAM doesn't support ROM - use AUTO for RAM_BLOCK_TYPE parameter"
		SEVERITY ERROR
		HELP_ID ALT_YGR_ROM_MEGA_RAM_INCOMPATIBLE;

		ASSERT (ROM_MODE() & ((OUTDATA_REG_A == "CLOCK1" & USED(clock1)) # !USED(clock1)))
		REPORT "Can't use clock1 port unless OUTDATA_REG_A parameter is set to CLOCK1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_ROM_CLK1_USED;

		ASSERT (ROM_MODE() & ((OUTDATA_REG_A == "CLOCK1" & USED(clock1)) # (OUTDATA_REG_A != "CLOCK1")))
		REPORT "Can't set OUTDATA_REG_A parameter to CLOCK1 unless clock1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_ROM_CLK1_UNUSED;

		ASSERT (ROM_MODE() & ((USED(aclr0) & (ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED"))) # !USED(aclr0)))
		REPORT "Can't use clear0 port unless ADDRESS_ACLR_A parameter or OUTDATA_ACLR_A parameter ( when q_a is registered ) is set to CLEAR0"
		SEVERITY ERROR
		HELP_ID ALT_YGR_ROM_CLR0_USED;

		ASSERT (ROM_MODE() & ((USED(aclr1) & (OUTDATA_ACLR_A == "CLEAR1") & (OUTDATA_REG_A != "UNREGISTERED")) # !USED(aclr1)))
		REPORT "Can't use clear1 port unless OUTDATA_ACLR_A parameter ( when q_a port is registered ) is set to CLEAR1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_ROM_CLR1_USED;

		ASSERT (ROM_MODE() & ((USED(aclr0) & (ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED"))) # ((OUTDATA_ACLR_A != "CLEAR0" # OUTDATA_REG_A == "UNREGISTERED") & ADDRESS_ACLR_A != "CLEAR0")))
		REPORT "Can't set ADDRESS_ACLR_A parameter or OUTDATA_ACLR_A parameter ( when q_a port is registered ) to CLEAR0 unless clear0 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_ROM_CLR0_UNUSED;

		ASSERT (ROM_MODE() & ((USED(aclr1) & (OUTDATA_ACLR_A == "CLEAR1") & (OUTDATA_REG_A != "UNREGISTERED")) # (OUTDATA_ACLR_A != "CLEAR1" # OUTDATA_REG_A == "UNREGISTERED")))
		REPORT "Can't set OUTDATA_ACLR_A parameter ( when q_a port is registered ) to CLEAR1 unless clear1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_ROM_CLR1_UNUSED;

		END GENERATE;
		-- end rom mode asserts


		IF (SINGLE_PORT_MODE()) GENERATE
		-- single port mode asserts
		
		ASSERT (SINGLE_PORT_MODE() & ((RAM_BLOCK_TYPE() == "LARGE" & (INDATA_ACLR_A == "NONE" # !USED(INDATA_ACLR_A)) & (ADDRESS_ACLR_A == "NONE" # !USED(ADDRESS_ACLR_A)) & (WRCONTROL_ACLR_A == "NONE" # !USED(WRCONTROL_ACLR_A)) & (USED(byteena_a) & BYTEENA_ACLR_A == "NONE" # !USED(byteena_a))) # (RAM_BLOCK_TYPE() != "LARGE")))
		REPORT "M-RAM doesn't support aclr ports for input registers"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_MRAM_NO_IP_CLEAR;

		ASSERT (SINGLE_PORT_MODE() & ((OUTDATA_REG_A == "CLOCK1" & USED(clock1)) # !USED(clock1)))
		REPORT "Can't use clock1 port unless OUTDATA_REG_A parameter is set to CLOCK1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_CLK1_USED;

		ASSERT (SINGLE_PORT_MODE() & ((OUTDATA_REG_A == "CLOCK1" & USED(clock1)) # (OUTDATA_REG_A != "CLOCK1")))
		REPORT "Can't set OUTDATA_REG_A parameter to CLOCK1 unless clock1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_CLK1_UNUSED;

		ASSERT (SINGLE_PORT_MODE() & ((USED(aclr0) & (ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED") # INDATA_ACLR_A == "CLEAR0" # WRCONTROL_ACLR_A == "CLEAR0" # (USED(byteena_a) & BYTEENA_ACLR_A == "CLEAR0"))) # !USED(aclr0)))
		REPORT "Can't use clear0 port unless ADDRESS_ACLR_A parameter, INDATA_ACLR_A parameter, WRCONTROL_ACLR_A parameter, OUTDATA_ACLR_A parameter ( when q_a port is registered ) or BYTEENA_ACLR_A parameter ( when byteena_a port is registered) is set to CLEAR0"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_CLR0_USED;

		ASSERT (SINGLE_PORT_MODE() & ((USED(aclr1) & (OUTDATA_ACLR_A == "CLEAR1" & OUTDATA_REG_A != "UNREGISTERED")) # !USED(aclr1)))
		REPORT "Can't use clear1 port unless OUTDATA_ACLR_A parameter ( when q_a port is registered ) is set to CLEAR1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_CLR1_USED;

		ASSERT (SINGLE_PORT_MODE() & ((USED(aclr0) & (ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED") # INDATA_ACLR_A == "CLEAR0" # WRCONTROL_ACLR_A == "CLEAR0" # (USED(byteena_a) & BYTEENA_ACLR_A == "CLEAR0"))) # (ADDRESS_ACLR_A != "CLEAR0" & (OUTDATA_ACLR_A != "CLEAR0" # OUTDATA_REG_A == "UNREGISTERED") & INDATA_ACLR_A != "CLEAR0" & WRCONTROL_ACLR_A != "CLEAR0" & (USED(byteena_a) & BYTEENA_ACLR_A != "CLEAR0" # !USED(byteena_a)))))
		REPORT "Can't set ADDRESS_ACLR_A parameter, INDATA_ACLR_A parameter, WRCONTROL_ACLR_A parameter,  BYTEENA_ACLR_A parameter ( when byteena_a port is registered) or OUTDATA_ACLR_A parameter ( when q_a port is registered ) to CLEAR0 unless clear0 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_CLR0_UNUSED;

		ASSERT (SINGLE_PORT_MODE() & ((USED(aclr1) & (OUTDATA_ACLR_A == "CLEAR1" & OUTDATA_REG_A != "UNREGISTERED")) # (OUTDATA_ACLR_A != "CLEAR1" # OUTDATA_REG_A == "UNREGISTERED")))
		REPORT "Can't set OUTDATA_ACLR_A parameter ( when q_a port is registered ) to CLEAR1 unless clear1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_CLR1_UNUSED;
		
		ASSERT (SINGLE_PORT_MODE() & (((WRCONTROL_ACLR_A == ADDRESS_ACLR_A) & NUMBER_OF_SINGLE_PORT_SEGMENTS() > 1) # NUMBER_OF_SINGLE_PORT_SEGMENTS() == 1))
		REPORT "Can't have different clears for wren_a port and address_a port when RAM is deeper than one ram block"
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_WRONG_CLEARS;

		ASSERT (RAM_BLOCK_TYPE() == "SMALL" & (WRCONTROL_ACLR_A == "NONE") # RAM_BLOCK_TYPE() != "SMALL")
		REPORT " Wren_a cannot have clear in single port mode for M512 block "
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_M512_WREN_CLR;
		
		-- end single port mode asserts
		END GENERATE;
		
		-- dual port mode asserts
		IF (DUAL_PORT_MODE()) GENERATE
		
		ASSERT (DUAL_PORT_MODE() & (NUM_WORDS_A * WIDTH_A == NUM_WORDS_B * WIDTH_B))		
		REPORT "Total number of bits of port A and port B should be the same for dual port mode"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_INCOMPATIBLE_NUMBER_OF_BITS;

		ASSERT (DUAL_PORT_MODE() & ((RAM_BLOCK_TYPE() == "AUTO" & DP_VALID_AUTO_COMBINATION()) # (RAM_BLOCK_TYPE() != "AUTO")))
		REPORT "No valid block type can be found for port A and port B widths and given set of parameters"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_AUTO_INCOMPATIBLE_WIDTHS;

		ASSERT (DUAL_PORT_MODE() & ((DUAL_PORT_VALID_COMBINATION() & RAM_BLOCK_TYPE() != "AUTO") # RAM_BLOCK_TYPE() == "AUTO"))
		REPORT "Not a valid combination of port A and port B widths"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_INCOMPATIBLE_WIDTHS;			

		ASSERT (DUAL_PORT_MODE() & ((RAM_BLOCK_TYPE() == "LARGE" & !USED(rden_b)) # RAM_BLOCK_TYPE() != "LARGE"))
		REPORT "M-RAM block type doesn't support rden_b port in dual port"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_NO_RDEN;
		
		ASSERT (DUAL_PORT_MODE() & ((RAM_BLOCK_TYPE() == "LARGE" & (INDATA_ACLR_A == "NONE" # !USED(INDATA_ACLR_A)) & (WRCONTROL_ACLR_A == "NONE" # !USED(WRCONTROL_ACLR_A)) & (ADDRESS_ACLR_B == "NONE" # !USED(ADDRESS_ACLR_B))& (ADDRESS_ACLR_A == "NONE" # !USED(ADDRESS_ACLR_A))& (USED(rden_b) & RDCONTROL_ACLR_B == "NONE" # !USED(rden_b)) & (USED(byteena_a) & BYTEENA_ACLR_A == "NONE" # !USED(byteena_a))) # (RAM_BLOCK_TYPE() != "LARGE")))
		REPORT "M-RAM doesn't support aclr ports for input registers"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_MRAM_NO_IP_CLEAR;
		
		ASSERT (DUAL_PORT_MODE() & (((OUTDATA_REG_B == "CLOCK1" # ADDRESS_REG_B == "CLOCK1" # (USED(rden_b) & RDCONTROL_REG_B == "CLOCK1"))& USED(clock1)) # !USED(clock1)))
		REPORT "Can't use clock1 port unless OUTDATA_REG_B parameter, ADDRESS_REG_B parameter or RDCONTROL_REG_B parameter (when rden_b port is used) is set to CLOCK1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_CLK1_USED;

		ASSERT (DUAL_PORT_MODE() & (((OUTDATA_REG_B == "CLOCK1" # ADDRESS_REG_B == "CLOCK1" # (USED(rden_b) & RDCONTROL_REG_B == "CLOCK1"))& USED(clock1)) # (OUTDATA_REG_B != "CLOCK1" & ADDRESS_REG_B != "CLOCK1" & (USED(rden_b)& RDCONTROL_REG_B != "CLOCK1" # !USED(rden_b)))))
		REPORT "Can't set OUTDATA_REG_B parameter, ADDRESS_REG_B parameter or RDCONTROL_REG_B parameter (when rden_b port is used) to CLOCK1 unless clock1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_CLK1_UNUSED;

		ASSERT (DUAL_PORT_MODE() & ((USED(aclr0) & (WRCONTROL_ACLR_A == "CLEAR0" # ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_B == "CLEAR0" & OUTDATA_REG_B != "UNREGISTERED") # INDATA_ACLR_A == "CLEAR0" # ADDRESS_ACLR_B == "CLEAR0" # (USED(byteena_a) & BYTEENA_ACLR_A == "CLEAR0") # (USED(rden_b) & RDCONTROL_ACLR_B == "CLEAR0"))) # !USED(aclr0)))
		REPORT "Can't use clear0 port unless ADDRESS_ACLR_A parameter, ADDRESS_ACLR_B parameter, INDATA_ACLR_A parameter, WRCONTROL_ACLR_A parameter, RDCONTROL_ACLR_B parameter (when rden_b port is used), OUTDATA_ACLR_B parameter ( when q_b port is registered ) or BYTEENA_ACLR_A parameter ( when byteena_a port is registered) is set to CLEAR0"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_CLR0_USED;

		ASSERT (DUAL_PORT_MODE() & ((USED(aclr1) & ((OUTDATA_ACLR_B == "CLEAR1" & OUTDATA_REG_B != "UNREGISTERED")# ADDRESS_ACLR_B == "CLEAR1" # (USED(rden_b) & RDCONTROL_ACLR_B == "CLEAR1"))) # !USED(aclr1)))
		REPORT "Can't use clear1 port unless OUTDATA_ACLR_B parameter ( when q_b port is registered ), ADDRESS_ACLR_B or RDCONTROL_ACLR_B (when rden_b is used) is set to CLEAR1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_CLR1_USED;

		ASSERT (DUAL_PORT_MODE() & ((USED(aclr0) & (WRCONTROL_ACLR_A == "CLEAR0" # ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_B == "CLEAR0" & OUTDATA_REG_B != "UNREGISTERED") # INDATA_ACLR_A == "CLEAR0" # WRCONTROL_ACLR_A != "CLEAR0" & ADDRESS_ACLR_B == "CLEAR0" # (USED(byteena_a) & BYTEENA_ACLR_A == "CLEAR0") # (USED(rden_b) & RDCONTROL_ACLR_B == "CLEAR0"))) # (ADDRESS_ACLR_A != "CLEAR0" & (OUTDATA_ACLR_B != "CLEAR0" # OUTDATA_REG_B == "UNREGISTERED") & ADDRESS_ACLR_B != "CLEAR0" & (USED(byteena_a) & BYTEENA_ACLR_A != "CLEAR0" # !USED(byteena_a)) & (USED(rden_b) & RDCONTROL_ACLR_B != "CLEAR0" # !USED(rden_b)))))
		REPORT "Can't set ADDRESS_ACLR_A parameter, INDATA_ACLR_A parameter, WRCONTROL_ACLR_A parameter,  BYTEENA_ACLR_A parameter ( when byteena_a port is registered), ADDRESS_ACLR_B parameter, RDCONTROL_ACLR_B parameter (when rden_b port is used) or OUTDATA_ACLR_B parameter ( when q_b port is registered ) to CLEAR0 unless clear0 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_CLR0_UNUSED;

		ASSERT (DUAL_PORT_MODE() & ((USED(aclr1) & ((OUTDATA_ACLR_B == "CLEAR1" & OUTDATA_REG_B != "UNREGISTERED") # ADDRESS_ACLR_B == "CLEAR1" # (USED(rden_b) & RDCONTROL_ACLR_B == "CLEAR1"))) # ((OUTDATA_ACLR_B != "CLEAR1" # OUTDATA_REG_B == "UNREGISTERED") & ADDRESS_ACLR_B != "CLEAR1" & (USED(rden_b) & RDCONTROL_ACLR_B != "CLEAR1" # !USED(rden_b)))))
		REPORT "Can't set ADDRESS_ACLR_B parameter, RDCONTROL_ACLR_B (when rden_b is used) or OUTDATA_ACLR_B parameter ( when q_b port is registered ) to CLEAR1 unless clear1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_CLR1_UNUSED;
		
		ASSERT (DUAL_PORT_MODE() & ((USED(rden_b) & (RDCONTROL_REG_B == ADDRESS_REG_B)) # !USED(rden_b)))
		REPORT "Inputs to B Side (rden_b port and address_b port) should be clocked by the same clock"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_SAME_CLK;
		
		ASSERT (DUAL_PORT_MODE() & ((USED(rden_b) & (RDCONTROL_ACLR_B == ADDRESS_ACLR_B # RDCONTROL_ACLR_B == "NONE" # ADDRESS_ACLR_B == "NONE")) # !USED(rden_b)))
		REPORT "Inputs to B Side (rden_b port and address_b port) should have the same clear"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_SAME_CLR;

		ASSERT (DUAL_PORT_MODE() & (((WRCONTROL_ACLR_A == ADDRESS_ACLR_A) & NUMBER_OF_DUAL_PORT_SEGMENTS() > 1) # NUMBER_OF_DUAL_PORT_SEGMENTS() == 1))
		REPORT "Can't have different clears for wren_a port and address_a port when RAM is deeper than one ram block"
		SEVERITY ERROR
		HELP_ID ALT_YGR_DP_WRONG_CLEARS;

		ASSERT (RAM_BLOCK_TYPE() == "SMALL" & (RDCONTROL_ACLR_B == "NONE") # RAM_BLOCK_TYPE() != "SMALL")
		REPORT " rden_b cannot have clear in simple dual port mode for M512 block "
		SEVERITY ERROR
		HELP_ID ALT_YGR_SP_M512_WREN_CLR;
		
		END GENERATE;
		-- end dual port mode asserts

		IF BIDIR_DUAL_PORT_MODE() GENERATE

		ASSERT (BIDIR_DUAL_PORT_MODE() & (NUM_WORDS_A * WIDTH_A == NUM_WORDS_B * WIDTH_B))		
		REPORT "Total number of bits of port A and port B should be the same for bidir dual port mode"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_INCOMPATIBLE_NUMBER_OF_BITS;
		
		ASSERT (BIDIR_DUAL_PORT_MODE() & RAM_BLOCK_TYPE() != "SMALL")
		REPORT "M512 block type doesn't support bidir dual mode"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_NO_SEAB;
		
		ASSERT (BIDIR_DUAL_PORT_MODE() & ((RAM_BLOCK_TYPE() != "AUTO" & BIDIR_DUAL_PORT_VALID_COMBINATION()) # (RAM_BLOCK_TYPE() == "AUTO")))
		REPORT "Not a valid combination of port A and port B widths"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_INCOMPATIBLE_WIDTHS;

		ASSERT (BIDIR_DUAL_PORT_MODE() & ((RAM_BLOCK_TYPE() == "AUTO" & BDP_VALID_AUTO_COMBINATION()) # (RAM_BLOCK_TYPE() != "AUTO")))
		REPORT "No valid block type can be found for port A and port B widths and given set of parameters"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_AUTO_INCOMPATIBLE_WIDTHS;
		
		ASSERT (BIDIR_DUAL_PORT_MODE() & ((RAM_BLOCK_TYPE() == "LARGE" & (INDATA_ACLR_A == "NONE" # !USED(INDATA_ACLR_A)) & (ADDRESS_ACLR_A == "NONE" # !USED(ADDRESS_ACLR_A)) & (WRCONTROL_ACLR_A == "NONE" # !USED(WRCONTROL_ACLR_A)) & (USED(byteena_a) & BYTEENA_ACLR_A == "NONE" # !USED(byteena_a))& (INDATA_ACLR_B == "NONE" # !USED(INDATA_ACLR_B)) & (ADDRESS_ACLR_B == "NONE" # !USED(ADDRESS_ACLR_B)) & (WRCONTROL_ACLR_B == "NONE" # !USED(WRCONTROL_ACLR_B)) & (USED(byteena_b) & BYTEENA_ACLR_B == "NONE" # !USED(byteena_b))) # (RAM_BLOCK_TYPE() != "LARGE")))
		REPORT "M-RAM doesn't support aclr ports for input registers"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_MRAM_NO_IP_CLEAR;
		
		ASSERT (BIDIR_DUAL_PORT_MODE() & (((OUTDATA_REG_A == "CLOCK1" # OUTDATA_REG_B == "CLOCK1" # ADDRESS_REG_B == "CLOCK1" # WRCONTROL_WRADDRESS_REG_B == "CLOCK1" # INDATA_REG_B == "CLOCK1" # (USED(byteena_b) & BYTEENA_REG_B == "CLOCK1"))& USED(clock1)) # !USED(clock1)))
		REPORT "Can't use clock1 port unless OUTDATA_REG_A parameter, OUTDATA_REG_B parameter, ADDRESS_REG_B parameter, WRCONTROL_WRADDRESS_REG_B parameter, INDATA_REG_B parameter or BYTEENA_REG_B parameter (when byteena_b is used) is set to CLOCK1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_CLK1_USED;

		ASSERT (BIDIR_DUAL_PORT_MODE() & (((OUTDATA_REG_A == "CLOCK1" # OUTDATA_REG_B == "CLOCK1" # ADDRESS_REG_B == "CLOCK1" # WRCONTROL_WRADDRESS_REG_B == "CLOCK1" # INDATA_REG_B == "CLOCK1" # (USED(byteena_b) & BYTEENA_REG_B == "CLOCK1"))& USED(clock1)) # (OUTDATA_REG_A != "CLOCK1" & OUTDATA_REG_B != "CLOCK1" & ADDRESS_REG_B != "CLOCK1" & WRCONTROL_WRADDRESS_REG_B != "CLOCK1" & INDATA_REG_B != "CLOCK1" & (USED(byteena_b) & BYTEENA_REG_B != "CLOCK1" # !USED(byteena_b))) ))
		REPORT "Can't set OUTDATA_REG_A parameter, OUTDATA_REG_B parameter, ADDRESS_REG_B parameter, WRCONTROL_WRADDRESS_REG_B parameter, INDATA_REG_B parameter or BYTEENA_REG_B parameter(when byteena_b is used) to  CLOCK1 unless clock1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_CLK1_UNUSED;

		ASSERT (BIDIR_DUAL_PORT_MODE() & ((USED(aclr0) & (ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED") # INDATA_ACLR_A == "CLEAR0" # WRCONTROL_ACLR_A == "CLEAR0" # (USED(byteena_a) & BYTEENA_ACLR_A == "CLEAR0") # ADDRESS_ACLR_B == "CLEAR0" # (OUTDATA_ACLR_B == "CLEAR0" & OUTDATA_REG_B != "UNREGISTERED") # INDATA_ACLR_B == "CLEAR0" # WRCONTROL_ACLR_B == "CLEAR0" # (USED(byteena_b) & BYTEENA_ACLR_B == "CLEAR0"))) # !USED(aclr0)))
		REPORT "Can't use clear0 unless ADDRESS_ACLR_A parameter, OUTDATA_ACLR_A parameter (when q_a is registered), INDATA_ACLR_A parameter, WRCONTROL_ACLR_A parameter, ADDRESS_ACLR_B parameter, BYTEENA_ACLR_A parameter(when byteena_a port is used), BYTEENA_ACLR_B parameter(when byteena_b is used), WRCONTROL_ACLR_B parameter, OUTDATA_ACLR_B parameter(when q_b is registered) or INDATA_ACLR_B parameter is set to clear0"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_CLR0_USED;

		ASSERT (BIDIR_DUAL_PORT_MODE() & ((USED(aclr0) & (ADDRESS_ACLR_A == "CLEAR0" # (OUTDATA_ACLR_A == "CLEAR0" & OUTDATA_REG_A != "UNREGISTERED")# INDATA_ACLR_A == "CLEAR0" # WRCONTROL_ACLR_A == "CLEAR0" # (USED(byteena_a) & BYTEENA_ACLR_A == "CLEAR0") # ADDRESS_ACLR_B == "CLEAR0" # (OUTDATA_ACLR_B == "CLEAR0" & OUTDATA_REG_B != "UNREGISTERED") # INDATA_ACLR_B == "CLEAR0" # WRCONTROL_ACLR_B == "CLEAR0" # (USED(byteena_b) & BYTEENA_ACLR_B == "CLEAR0"))) # (ADDRESS_ACLR_A != "CLEAR0" & (OUTDATA_ACLR_A != "CLEAR0" # OUTDATA_REG_A == "UNREGISTERED") & INDATA_ACLR_A != "CLEAR0" & WRCONTROL_ACLR_A != "CLEAR0" & (USED(byteena_a) & BYTEENA_ACLR_A != "CLEAR0" # !USED(byteena_a)) & ADDRESS_ACLR_B != "CLEAR0" & (OUTDATA_ACLR_B != "CLEAR0" # OUTDATA_REG_B == "UNREGISTERED") & INDATA_ACLR_B != "CLEAR0" & WRCONTROL_ACLR_B != "CLEAR0" # (USED(byteena_b) & BYTEENA_ACLR_B != "CLEAR0" # !USED(byteena_b)))))
		REPORT "Can't set ADDRESS_ACLR_A parameter, OUTDATA_ACLR_A parameter(when q_a is registered), INDATA_ACLR_A parameter, WRCONTROL_ACLR_A parameter, ADDRESS_ACLR_B parameter, BYTEENA_ACLR_A parameter (when byteena_a port is used), BYTEENA_ACLR_B parameter(when byteena_b is used), WRCONTROL_ACLR_B parameter, OUTDATA_ACLR_B parameter (when q_b is registered) OR INDATA_ACLR_B parameter to CLEAR0 unless clear0 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_CLR0_UNUSED;

		ASSERT (BIDIR_DUAL_PORT_MODE() & ((USED(aclr1) & ((OUTDATA_ACLR_A == "CLEAR1" & OUTDATA_REG_A != "UNREGISTERED") # ADDRESS_ACLR_B == "CLEAR1" # (OUTDATA_ACLR_B == "CLEAR1" & OUTDATA_REG_B != "UNREGISTERED") # INDATA_ACLR_B == "CLEAR1" # WRCONTROL_ACLR_B == "CLEAR1" # (USED(byteena_b) & BYTEENA_ACLR_B == "CLEAR1"))) # !USED(aclr1)))
		REPORT "Can't use clear1 unless OUTDATA_ACLR_A parameter (when q_a is registered), ADDRESS_ACLR_B parameter, BYTEENA_ACLR_B parameter (when byteena_b is used), WRCONTROL_ACLR_B parameter, OUTDATA_ACLR_B parameter (when q_b is registered) or INDATA_ACLR_B parameter is set to CLEAR1"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_CLR1_USED;

		ASSERT (BIDIR_DUAL_PORT_MODE() & ((USED(aclr1) & ((OUTDATA_ACLR_A == "CLEAR1" & OUTDATA_REG_A != "UNREGISTERED") # ADDRESS_ACLR_B == "CLEAR1" # (OUTDATA_ACLR_B == "CLEAR1" & OUTDATA_REG_B != "UNREGISTERED") # INDATA_ACLR_B == "CLEAR1" # WRCONTROL_ACLR_B == "CLEAR1" # (USED(byteena_b) & BYTEENA_ACLR_B == "CLEAR1"))) # ((OUTDATA_ACLR_A != "CLEAR1" # OUTDATA_REG_A == "UNREGISTERED") & ADDRESS_ACLR_B != "CLEAR1" & (OUTDATA_ACLR_B != "CLEAR1" # OUTDATA_REG_B == "UNREGISTERED") & INDATA_ACLR_B != "CLEAR1" & WRCONTROL_ACLR_B != "CLEAR1" # (USED(byteena_b) & BYTEENA_ACLR_B != "CLEAR1" # !USED(byteena_b)))))
		REPORT "Can't set OUTDATA_ACLR_A parameter (when q_a is registered), ADDRESS_ACLR_B parameter, BYTEENA_ACLR_B parameter(when byteena_b is used), WRCONTROL_ACLR_B parameter, OUTDATA_ACLR_B parameter(when q_b is registered) or INDATA_ACLR_B parameter to CLEAR1 unless clear1 port is used"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDP_CLR1_UNUSED;

		ASSERT (BIDIR_DUAL_PORT_MODE() & (WRCONTROL_WRADDRESS_REG_B == ADDRESS_REG_B) & (WRCONTROL_WRADDRESS_REG_B == INDATA_REG_B) & ((USED(byteena_b) & (WRCONTROL_WRADDRESS_REG_B == BYTEENA_REG_B)) # !USED(byteena_b)))
		REPORT "Write Inputs on B Side -- data_b port, wren_b port, address_b port and byteena_b port (if used) should be registered by the same clock"
		SEVERITY ERROR
		HELP_ID ALT_YGR_USE_COMMON_CLOCK_PORT_B;

		ASSERT (BIDIR_DUAL_PORT_MODE() & SAME_CLEAR_USED())
		REPORT "Write Inputs on B Side -- data_b port, wren_b port, address_b port and byteena_b port (if used) should have the same clear"
		SEVERITY ERROR
		HELP_ID ALT_YGR_USE_COMMON_CLEAR_PORT_B;

		ASSERT (BIDIR_DUAL_PORT_MODE() & (((WRCONTROL_ACLR_A == ADDRESS_ACLR_A) & NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() > 1) # NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() == 1))
		REPORT "Can't have different clears for wren_a port and address_a port when RAM is deeper than one ram block"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDPA_WRONG_CLEARS;

		ASSERT (BIDIR_DUAL_PORT_MODE() & (((WRCONTROL_ACLR_B == ADDRESS_ACLR_B) & NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() > 1) # NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() == 1))
		REPORT "Can't have different clears for wren_b port and address_b port when RAM is deeper than one ram block"
		SEVERITY ERROR
		HELP_ID ALT_YGR_BDPB_WRONG_CLEARS;
		
		END GENERATE;	
		
		ASSERT (RAM_BLOCK_TYPE == "M512" & FAMILY_HAS_M512() # RAM_BLOCK_TYPE != "M512")
		REPORT "Device family % does not have M512 ram blocks. Using available memory blocks instead" DEVICE_FAMILY
		SEVERITY WARNING
		HELP_ID ALT_YGR_NO_M512;

		ASSERT (RAM_BLOCK_TYPE == "M4K" & FAMILY_STRATIX() # RAM_BLOCK_TYPE != "M4K")
		REPORT "Device family % does not have M4K ram blocks. Using available memory blocks instead" DEVICE_FAMILY
		SEVERITY WARNING
		HELP_ID ALT_YGR_NO_M4K;


		ASSERT ((RAM_BLOCK_TYPE == "MEGARAM" # RAM_BLOCK_TYPE == "M-RAM") & FAMILY_HAS_MEGARAM() # (RAM_BLOCK_TYPE != "MEGARAM" & RAM_BLOCK_TYPE != "M-RAM"))
		REPORT "Device family % does not have M-RAM. Using available memory blocks instead" DEVICE_FAMILY
		SEVERITY WARNING
		HELP_ID ALT_YGR_NO_MEGARAM;

		IF FAMILY_STRATIX() == 1 GENERATE	
		IF !BIDIR_DUAL_PORT_MODE() # (BIDIR_DUAL_PORT_MODE() & !SWAP_NEEDED()) GENERATE
		-- connecting clocks
		ram_block[][].clk0 = clock0;
		IF USED(clocken0) GENERATE
			ram_block[][].ena0 = clocken0;
		ELSE GENERATE
			ram_block[][].ena0 = VCC;
		END GENERATE;
		IF USED(clock1) GENERATE
			ram_block[][].clk1 = clock1;
			IF USED(clocken1) GENERATE
				ram_block[][].ena1 = clocken1;
			END GENERATE;
		END GENERATE;
		
		-- connecting clears
		IF USED(aclr0) & NEED_TO_CONNECT_CLEAR0() GENERATE
			ram_block[][].clr0 = aclr0;
		END GENERATE;
		IF USED(aclr1) & NEED_TO_CONNECT_CLEAR1() GENERATE
			ram_block[][].clr1 = aclr1;
		END GENERATE;
		END GENERATE;	
		
		-- rom mode	
		IF ROM_MODE() GENERATE
			-- connecting dataout ports
			IF NUMBER_OF_ROM_SEGMENTS() == 1 GENERATE
				q_a[] = ram_block[0][].portadataout[0];
				FOR i IN 0 TO NUMBER_OF_ROM_SLICES() -1 GENERATE
					ram_block[0][i].portaaddr[] = address_a[];
				END GENERATE;
			ELSE GENERATE
				q_a[] = rom_mux.result[];
				IF NUMBER_OF_ROM_SEGMENTS() > 1 GENERATE
					FOR j IN 0 TO NUMBER_OF_ROM_SEGMENTS()-2 GENERATE
						FOR i IN 0 TO ROM_ADDRESS_SIZE()-1 GENERATE
							ram_block[j][].portaaddr[i] = address_a[i];
						END GENERATE;
					END GENERATE;
				END GENERATE;	
				FOR i IN 0 TO ROM_LAST_SEGMENT_ADDRESS()-1 GENERATE
					ram_block[NUMBER_OF_ROM_SEGMENTS()-1][].portaaddr[i] = address_a[i];
				END GENERATE;
				
				FOR i IN 0 TO NUMBER_OF_ROM_SEGMENTS()-1 GENERATE
					rom_mux.data[i][] = ram_block[i][].portadataout[0];
				END GENERATE;
				IF OUTPUT_A_REGISTERED() GENERATE
					rdaddress_buffer[0][].clk = clock0;
					IF USED(clocken0) GENERATE
						rdaddress_buffer[0][].ena = clocken0;
					END GENERATE;
					IF OUTDATA_REG_A == "CLOCK1" GENERATE
						rdaddress_buffer[1][].clk = clock1;
						IF USED(clocken1) GENERATE
							rdaddress_buffer[1][].ena = clocken1;
						END GENERATE;
					ELSE GENERATE
						rdaddress_buffer[1][].clk = clock0;
						IF USED(clocken0) GENERATE
							rdaddress_buffer[1][].ena = clocken0;
						END GENERATE;
					END GENERATE; 
				ELSE GENERATE
					rdaddress_buffer[].clk = clock0;
					IF USED(clocken0) GENERATE
						rdaddress_buffer[].ena = clocken0;
					END GENERATE;
				END GENERATE;
				
				FOR i IN ROM_ADDRESS_SIZE() TO WIDTHAD_A-1 GENERATE
					IF OUTPUT_A_REGISTERED() GENERATE
						IF ADDRESS_ACLR_A == "CLEAR0" GENERATE
							rdaddress_buffer[0][i-ROM_ADDRESS_SIZE()].d = address_a[i] & !aclr0;
						ELSE GENERATE
							rdaddress_buffer[0][i-ROM_ADDRESS_SIZE()].d = address_a[i];
						END GENERATE;
					ELSE GENERATE
						IF ADDRESS_ACLR_A == "CLEAR0" GENERATE
							rdaddress_buffer[i-ROM_ADDRESS_SIZE()].d = address_a[i] & !aclr0;					
						ELSE GENERATE
							rdaddress_buffer[i-ROM_ADDRESS_SIZE()].d = address_a[i];
						END GENERATE;
					END GENERATE;	
				END GENERATE;
				IF OUTPUT_A_REGISTERED() GENERATE 
					rdaddress_buffer[1][].d = rdaddress_buffer[0][].q;
					rom_mux.sel[] = rdaddress_buffer[1][].q;
				ELSE GENERATE
					rom_mux.sel[] = rdaddress_buffer[].q;
				END GENERATE;		
			END GENERATE;
		END GENERATE;
		-- end rom mode
		-- update out registered and the buffers for single, dual and bd modes

		-- single port mode
		IF SINGLE_PORT_MODE() GENERATE
			IF NUMBER_OF_SINGLE_PORT_SEGMENTS() == 1 GENERATE
				FOR i IN 0 TO NUMBER_OF_SINGLE_PORT_SLICES()-1 GENERATE
					ram_block[0][i].portaaddr[] = address_a[];
				END GENERATE;
				IF SP_SPECIAL_BYTEENA() GENERATE
					FOR i IN 0 TO NUMBER_OF_SINGLE_PORT_SLICES()-1 GENERATE
						IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
							ram_block[0][i].portawe = wren_a & byteena_a[FLOOR(i / BYTE_SIZE)] & !aclr0;
						ELSE GENERATE
							ram_block[0][i].portawe = wren_a & byteena_a[FLOOR(i / BYTE_SIZE)];					
						END GENERATE;
					END GENERATE;
					q_a[] = ram_block[0][].portadataout[0];
					ram_block[0][].portadatain[0] = data_a[];
--					FOR i IN 0 TO WIDTH_A-1 GENERATE
--						ram_block[0][BLOCK_ID(i)].portadatain[NORMALIZE(i)] = data_a[i];
--						q_a[i] = ram_block[0][BLOCK_ID(i)].portadataout[NORMALIZE(i)];
--					END GENERATE;
				ELSE GENERATE
					ram_block[0][].portawe = wren_a;
					IF USED(byteena_a)GENERATE
						FOR i IN 0 TO WIDTH_A-1 GENERATE
							ram_block[0][BLOCK_ID(i)].portadatain[NORMALIZE(i)] = data_a[i];
							q_a[i] = ram_block[0][BLOCK_ID(i)].portadataout[NORMALIZE(i)];
						END GENERATE;
						IF USED(byteena_a) GENERATE
							FOR i IN 0 TO NUMBER_OF_SINGLE_PORT_SLICES()-1 GENERATE
								ram_block[0][i].portabyteenamasks[0] = byteena_a[i];
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						q_a[] = ram_block[0][].portadataout[0];
						ram_block[0][].portadatain[0] = data_a[];
					END GENERATE;
				END GENERATE;
			ELSE GENERATE
				-- mux section
				q_a[] = sp_mux.result[];
				IF NUMBER_OF_SINGLE_PORT_SEGMENTS() > 1 GENERATE
					FOR j IN 0 TO NUMBER_OF_SINGLE_PORT_SEGMENTS()-2 GENERATE			
						FOR i IN 0 TO SINGLE_PORT_ADDRESS_SIZE()-1 GENERATE
							ram_block[j][].portaaddr[i] = address_a[i];
						END GENERATE;			
					END GENERATE;
				END GENERATE; 
				FOR i IN 0 TO SINGLE_PORT_LAST_SEGMENT_ADDRESS()-1 GENERATE
					ram_block[NUMBER_OF_SINGLE_PORT_SEGMENTS()-1][].portaaddr[i] = address_a[i];
				END GENERATE;
				
				IF OUTPUT_A_REGISTERED() GENERATE
					wraddress_buffer[0][].clk = clock0;
					IF USED(clocken0) GENERATE
						wraddress_buffer[0][].ena = clocken0;
					END GENERATE;
					IF OUTDATA_REG_A == "CLOCK0" GENERATE
						wraddress_buffer[1][].clk = clock0;
						IF USED(clocken0) GENERATE
							wraddress_buffer[1][].ena = clocken0;
						END GENERATE;
					ELSE GENERATE
						IF OUTDATA_REG_A == "CLOCK1" GENERATE
							wraddress_buffer[1][].clk = clock1;
							IF USED(clocken1) GENERATE
								wraddress_buffer[1][].ena = clocken1;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					wraddress_buffer[].clk = clock0;
					IF USED(clocken0) GENERATE
						wraddress_buffer[].ena = clocken0;
					END GENERATE;
				END GENERATE;
				
				FOR i IN SINGLE_PORT_ADDRESS_SIZE() TO WIDTHAD_A-1 GENERATE
					IF OUTPUT_A_REGISTERED() GENERATE
						IF ADDRESS_ACLR_A == "CLEAR0" GENERATE
							wraddress_buffer[0][i-SINGLE_PORT_ADDRESS_SIZE()].d = address_a[i] & !aclr0;
						ELSE GENERATE
							wraddress_buffer[0][i-SINGLE_PORT_ADDRESS_SIZE()].d = address_a[i];
						END GENERATE;						
						wraddress_buffer[1][].d = wraddress_buffer[0][].q;
						sp_mux.sel[] = wraddress_buffer[1][].q;
					ELSE GENERATE
						IF ADDRESS_ACLR_A == "CLEAR0" GENERATE
							wraddress_buffer[i-SINGLE_PORT_ADDRESS_SIZE()].d = address_a[i] & !aclr0;					
						ELSE GENERATE						
							wraddress_buffer[i-SINGLE_PORT_ADDRESS_SIZE()].d = address_a[i];
						END GENERATE;						
						sp_mux.sel[] = wraddress_buffer[].q;
					END GENERATE;	
				END GENERATE;
				-- decode section
				sp_decode.enable = wren_a;
				FOR i IN SINGLE_PORT_ADDRESS_SIZE() TO WIDTHAD_A-1 GENERATE
					IF ADDRESS_ACLR_A == "CLEAR0" GENERATE
						sp_decode.data[i-SINGLE_PORT_ADDRESS_SIZE()] = address_a[i] & !aclr0;				
					ELSE GENERATE
						sp_decode.data[i-SINGLE_PORT_ADDRESS_SIZE()] = address_a[i];
					END GENERATE;
				END GENERATE;
				FOR i IN 0 TO NUMBER_OF_SINGLE_PORT_SEGMENTS()-1 GENERATE
					IF SP_SPECIAL_BYTEENA() GENERATE
						FOR j IN 0 TO NUMBER_OF_SINGLE_PORT_SLICES()-1 GENERATE
							IF BYTEENA_ACLR_A == "CLEAR0" GENERATE			
								ram_block[i][j].portawe = sp_decode.eq[i] & byteena_a[FLOOR(j / BYTE_SIZE)] & !aclr0;
							ELSE GENERATE
								ram_block[i][j].portawe = sp_decode.eq[i] & byteena_a[FLOOR(j / BYTE_SIZE)];					
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						ram_block[i][].portawe = sp_decode.eq[i];				
					END GENERATE;
				END GENERATE;
				
				IF USED(byteena_a)& !SP_SPECIAL_BYTEENA() GENERATE
					FOR i IN 0 TO WIDTH_A-1 GENERATE
						ram_block[][BLOCK_ID(i)].portadatain[NORMALIZE(i)] = data_a[i];
					END GENERATE;
					FOR i IN 0 TO NUMBER_OF_SINGLE_PORT_SEGMENTS()-1 GENERATE
						FOR j IN 0 TO WIDTH_A-1 GENERATE
							sp_mux.data[i][j] = ram_block[i][BLOCK_ID(j)].portadataout[NORMALIZE(j)];
						END GENERATE;
					END GENERATE;
					IF USED(byteena_a) & !SP_SPECIAL_BYTEENA() GENERATE
						FOR i IN 0 TO NUMBER_OF_SINGLE_PORT_SLICES()-1 GENERATE
							ram_block[][i].portabyteenamasks[0] = byteena_a[i];
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					FOR i IN 0 TO WIDTH_A-1 GENERATE
						ram_block[][i].portadatain[0] = data_a[i];
					END GENERATE;
					FOR i IN 0 TO NUMBER_OF_SINGLE_PORT_SEGMENTS()-1 GENERATE
						sp_mux.data[i][] = ram_block[i][].portadataout[0];			
					END GENERATE;

				END GENERATE;
		
			END GENERATE;
		END GENERATE;
		-- end single port mode
		
		IF DUAL_PORT_MODE() & ((RAM_BLOCK_TYPE() != "AUTO" & DUAL_PORT_VALID_COMBINATION()) # (RAM_BLOCK_TYPE() == "AUTO" & DP_VALID_AUTO_COMBINATION())) GENERATE
			IF NUMBER_OF_DUAL_PORT_SEGMENTS() == 1 GENERATE
				IF DONT_SPLIT() GENERATE
					ram_block[0][0].portaaddr[] = address_a[];
					ram_block[0][0].portbaddr[] = address_b[];
					ram_block[0][0].portawe = wren_a;
					IF USED(rden_b) GENERATE
						ram_block[0][0].portbrewe = rden_b;
					ELSE GENERATE
						ram_block[0][0].portbrewe = VCC;
					END GENERATE;
					ram_block[0][0].portabyteenamasks[] = byteena_a[];
					ram_block[0][0].portadatain[] = data_a[];
					q_b[] = ram_block[0][0].portbdataout[];			
				ELSE GENERATE -- split up segments
				FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
					ram_block[0][i].portaaddr[] = address_a[];
					ram_block[0][i].portbaddr[] = address_b[];
				END GENERATE;	
				IF DP_SPECIAL_BYTEENA() GENERATE
					FOR j IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
						IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
							ram_block[0][j].portawe = wren_a & byteena_a[FLOOR(j / BYTE_SIZE)] & !aclr0;				
						ELSE GENERATE
							ram_block[0][j].portawe = wren_a & byteena_a[FLOOR(j / BYTE_SIZE)];								
						END GENERATE;
					END GENERATE;
				ELSE GENERATE				
					ram_block[0][].portawe = wren_a;
				END GENERATE;
				IF USED(rden_b) GENERATE
					ram_block[0][].portbrewe = rden_b;
				ELSE GENERATE
					ram_block[0][].portbrewe = VCC;
				END GENERATE;
				IF USED(byteena_a) &!DP_SPECIAL_BYTEENA() GENERATE
					IF NUMBER_OF_DUAL_PORT_SLICES() == 1 GENERATE
						IF USED(byteena_a) & !DP_SPECIAL_BYTEENA() GENERATE
							ram_block[0][].portabyteenamasks[] = byteena_a[];
						END GENERATE;
						q_b[] = ram_block[0][].portbdataout[];						
						ram_block[0][].portadatain[] = data_a[];
					ELSE GENERATE
						IF USED(byteena_a) & !DP_SPECIAL_BYTEENA() GENERATE
							IF WIDTH_A > WIDTH_B GENERATE
								FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO NUMBER_OF_DUAL_PORT_BYTES()-1 GENERATE
										ram_block[0][i].portabyteenamasks[j] = byteena_a[i+j*NUMBER_OF_DUAL_PORT_SLICES()];
									END GENERATE;
								END GENERATE;
							ELSE GENERATE
								FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
									ram_block[0][i].portabyteenamasks[0] = byteena_a[i];
								END GENERATE;
							END GENERATE;
						END GENERATE;
						IF WIDTH_A > WIDTH_B GENERATE
							FOR i IN 0 TO WIDTH_B-1 GENERATE
								q_b[i] = ram_block[0][DP_BLOCK_ID_B(i)].portbdataout[DP_NORMALIZE_B(i)];
							END GENERATE;
							FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO A_B_RATIO()*BYTE_SIZE-1 GENERATE
									ram_block[0][i].portadatain[j] = data_a[BYTE_POSITION(i,j)];		
								END GENERATE;
							END GENERATE;		
						ELSE GENERATE
							FOR i IN 0 TO WIDTH_A-1 GENERATE
								ram_block[0][DP_BLOCK_ID_A(i)].portadatain[DP_NORMALIZE_A(i)] = data_a[i];
							END GENERATE;
							FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO B_A_RATIO()*BYTE_SIZE-1 GENERATE
									q_b[BYTE_POSITION(i,j)] = ram_block[0][i].portbdataout[j];
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF WIDTH_A > WIDTH_B GENERATE
						q_b[] = ram_block[0][].portbdataout[0];
						FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
							FOR j IN 0 TO A_B_RATIO()-1 GENERATE
								ram_block[0][i].portadatain[j] = data_a[POSITION(i,j)];
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						ram_block[0][].portadatain[0] = data_a[];
						FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
							FOR j IN 0 TO B_A_RATIO()-1 GENERATE
								q_b[POSITION(i,j)] = ram_block[0][i].portbdataout[j];
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				END GENERATE; -- split up
			ELSE GENERATE
				IF NUMBER_OF_DUAL_PORT_SEGMENTS() > 1 GENERATE
					FOR j IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-2 GENERATE
						FOR i IN 0 TO DUAL_PORT_ADDRESS_SIZE_A()-1 GENERATE
							ram_block[j][].portaaddr[i] = address_a[i];
						END GENERATE;
					END GENERATE;
				END GENERATE;	
				FOR i IN 0 TO DUAL_PORT_LAST_SEGMENT_ADDRESS_A()-1 GENERATE
					ram_block[NUMBER_OF_DUAL_PORT_SEGMENTS()-1][].portaaddr[i] = address_a[i];
				END GENERATE;
				IF NUMBER_OF_DUAL_PORT_SEGMENTS() > 1 GENERATE
					FOR j IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-2 GENERATE
						FOR i IN 0 TO DUAL_PORT_ADDRESS_SIZE_B()-1 GENERATE
							ram_block[j][].portbaddr[i] = address_b[i];
						END GENERATE;
					END GENERATE;
				END GENERATE;	
				FOR i IN 0 TO DUAL_PORT_LAST_SEGMENT_ADDRESS_B()-1 GENERATE
					ram_block[NUMBER_OF_DUAL_PORT_SEGMENTS()-1][].portbaddr[i] = address_b[i];
				END GENERATE;


				-- connecting clocks, clears and enables for the address_buffers
				IF USED(rden_b) GENERATE
					IF OUTPUT_B_REGISTERED() GENERATE
						IF OUTDATA_REG_B == "CLOCK0" GENERATE
							address_buffer_b[].clk = clock0;
							IF USED(clocken0) GENERATE
								address_buffer_b[].ena = clocken0;-- & rden_reg.q;
							END GENERATE;
						ELSE GENERATE
							IF OUTDATA_REG_B == "CLOCK1" GENERATE
								address_buffer_b[].clk = clock1;
								IF USED(clocken1) GENERATE
									address_buffer_b[].ena = clocken1;-- & rden_reg.q;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;	
					IF ADDRESS_REG_B == "CLOCK0" GENERATE
						address_latch.clk = clock0;
						IF USED(clocken0) GENERATE
							address_latch.ena = clocken0;
						END GENERATE;
					ELSE GENERATE
						IF ADDRESS_REG_B == "CLOCK1" GENERATE
							address_latch.clk = clock1;
							IF USED(clocken1) GENERATE
								address_latch.ena = clocken1;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					IF RDCONTROL_ACLR_B != "NONE" GENERATE
						IF RDCONTROL_ACLR_B == "CLEAR0" GENERATE
							address_latch.aclre = aclr0;
						ELSE GENERATE
							IF RDCONTROL_ACLR_B == "CLEAR1" GENERATE
								address_latch.aclre = aclr1;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF OUTPUT_B_REGISTERED() GENERATE
						IF ADDRESS_REG_B == "CLOCK0" GENERATE
							address_buffer_b[0][].clk = clock0;
							IF USED(clocken0) GENERATE
								address_buffer_b[0][].ena = clocken0;
							END GENERATE;
						ELSE GENERATE
							IF ADDRESS_REG_B == "CLOCK1" GENERATE
								address_buffer_b[0][].clk = clock1;
								IF USED(clocken0) GENERATE
									address_buffer_b[0][].ena = clocken1;
								END GENERATE;
							END GENERATE;
						END GENERATE;
						IF OUTDATA_REG_B == "CLOCK0" GENERATE
							address_buffer_b[1][].clk = clock0;
							IF USED(clocken0) GENERATE
								address_buffer_b[1][].ena = clocken0;
							END GENERATE;
						ELSE GENERATE
							IF OUTDATA_REG_B == "CLOCK1" GENERATE
								address_buffer_b[1][].clk = clock1;
								IF USED(clocken1) GENERATE
									address_buffer_b[1][].ena = clocken1;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						IF ADDRESS_REG_B == "CLOCK0" GENERATE
							address_buffer_b[].clk = clock0;
							IF USED(clocken0) GENERATE
								address_buffer_b[].ena = clocken0;
							END GENERATE;
						ELSE GENERATE
							IF ADDRESS_REG_B == "CLOCK1" GENERATE
								address_buffer_b[].clk = clock1;
								IF USED(clocken0) GENERATE
									address_buffer_b[].ena = clocken1;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE; -- !used rden_b	
				-- end clocking of buffers
			
				--connecting the data out through mux
				-- B Side
				q_b[] = dp_mux_b.result[];
				FOR i IN DUAL_PORT_ADDRESS_SIZE_B() TO WIDTHAD_B-1 GENERATE
					IF USED(rden_b) GENERATE
						address_latch.e = rden_b;
						IF ADDRESS_ACLR_B == "CLEAR0" GENERATE
							address_latch.d[i-DUAL_PORT_ADDRESS_SIZE_B()] = address_b[i] & !aclr0;
						ELSE GENERATE
							IF ADDRESS_ACLR_B == "CLEAR1" GENERATE
								address_latch.d[i-DUAL_PORT_ADDRESS_SIZE_B()] = address_b[i] & !aclr1;							
							ELSE GENERATE
								address_latch.d[i-DUAL_PORT_ADDRESS_SIZE_B()] = address_b[i];						
							END GENERATE;
						END GENERATE;
						IF OUTPUT_B_REGISTERED() GENERATE
							address_buffer_b[].d = address_latch.q[];
							dp_mux_b.sel[] = address_buffer_b[].q;						
						ELSE GENERATE
							dp_mux_b.sel[] = address_latch.q[];
						END GENERATE;					
					ELSE GENERATE				
						IF OUTPUT_B_REGISTERED() GENERATE
							IF ADDRESS_ACLR_B == "CLEAR0" GENERATE
								address_buffer_b[0][i-DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr0;
							ELSE GENERATE
								IF ADDRESS_ACLR_B == "CLEAR1" GENERATE
									address_buffer_b[0][i-DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr1;						
								ELSE GENERATE
									address_buffer_b[0][i-DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i];					
								END GENERATE;
							END GENERATE;
							address_buffer_b[1][].d = address_buffer_b[0][].q;
							dp_mux_b.sel[] = address_buffer_b[1][].q;
						ELSE GENERATE
							IF ADDRESS_ACLR_B == "CLEAR0" GENERATE
								address_buffer_b[i-DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr0;
							ELSE GENERATE
								IF ADDRESS_ACLR_B == "CLEAR1" GENERATE
									address_buffer_b[i-DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr1;						
								ELSE GENERATE
									address_buffer_b[i-DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i];					
								END GENERATE;
							END GENERATE;
							dp_mux_b.sel[] = address_buffer_b[].q;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				-- end mux			
				
				-- connecting the decode, thats providing the enable
				-- A side
				dp_decode_a.enable = wren_a;
				FOR i IN DUAL_PORT_ADDRESS_SIZE_A() TO WIDTHAD_A-1 GENERATE
					dp_decode_a.data[i-DUAL_PORT_ADDRESS_SIZE_A()] = address_a[i];
				END GENERATE;
				FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
					IF !DP_SPECIAL_BYTEENA() GENERATE
						ram_block[i][].portawe = dp_decode_a.eq[i];
					END GENERATE;
				END GENERATE;
			
				-- B Side	
			%	IF USED(rden_b) GENERATE
					dp_decode_b.enable = rden_b;
				ELSE GENERATE
					dp_decode_b.enable = VCC;
				END GENERATE;
				FOR i IN DUAL_PORT_ADDRESS_SIZE_B() TO WIDTHAD_B-1 GENERATE
					IF ADDRESS_ACLR_B == "CLEAR0" GENERATE
						dp_decode_b.data[i-DUAL_PORT_ADDRESS_SIZE_B()] = address_b[i] & !aclr0;
					ELSE GENERATE
						IF ADDRESS_ACLR_B == "CLEAR1" GENERATE
							dp_decode_b.data[i-DUAL_PORT_ADDRESS_SIZE_B()] = address_b[i] & !aclr1;
						ELSE GENERATE
							dp_decode_b.data[i-DUAL_PORT_ADDRESS_SIZE_B()] = address_b[i];
						END GENERATE;
					END GENERATE;
				END GENERATE; %
				FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
					IF USED(rden_b) GENERATE
						ram_block[i][].portbrewe = rden_b;
					ELSE GENERATE
						ram_block[i][].portbrewe = VCC;
					END GENERATE;
				END GENERATE;
				-- end decode

				--datain and out of the ram
				IF USED(byteena_a) & !DP_SPECIAL_BYTEENA() GENERATE
					-- connecting byte enable masks
					IF NUMBER_OF_DUAL_PORT_SLICES() == 1 GENERATE
						IF DP_SPECIAL_BYTEENA() GENERATE
							FOR j IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
								IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
									ram_block[j][].portawe = dp_decode_a.eq[j] & byteena_a[] & !aclr0;					
								ELSE GENERATE
									ram_block[j][].portawe = dp_decode_a.eq[j] & byteena_a[];											
								END GENERATE;
							END GENERATE;
						ELSE GENERATE
							ram_block[][].portabyteenamasks[] = byteena_a[];
						END GENERATE;
					ELSE GENERATE
						IF USED(byteena_a) GENERATE
							IF WIDTH_A > WIDTH_B GENERATE
								FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO NUMBER_OF_DUAL_PORT_BYTES()-1 GENERATE
										IF DP_SPECIAL_BYTEENA() GENERATE
											FOR j IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
												IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
													ram_block[j][i].portawe = dp_decode_a.eq[j] & byteena_a[i+j*NUMBER_OF_DUAL_PORT_SLICES()] & !aclr0;
												ELSE GENERATE
													ram_block[j][i].portawe = dp_decode_a.eq[j] & byteena_a[i+j*NUMBER_OF_DUAL_PORT_SLICES()];										
												END GENERATE;
											END GENERATE;
										ELSE GENERATE
											ram_block[][i].portabyteenamasks[j] = byteena_a[i+j*NUMBER_OF_DUAL_PORT_SLICES()];									
										END GENERATE;
									END GENERATE;
								END GENERATE;
							ELSE GENERATE
								FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
									IF DP_SPECIAL_BYTEENA() GENERATE
										FOR j IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
											IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
												ram_block[j][i].portawe = dp_decode_a.eq[j] & byteena_a[i]& !aclr0;
											ELSE GENERATE
												ram_block[j][i].portawe = dp_decode_a.eq[j] & byteena_a[i];									
											END GENERATE;
										END GENERATE;
									ELSE GENERATE
										ram_block[][i].portabyteenamasks[0] = byteena_a[i];								
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					

					--connecting data 
					IF DONT_SPLIT() GENERATE
						dp_mux_b.data[][] = ram_block[][].portbdataout[];
						ram_block[][].portadatain[] = data_a[];
					ELSE GENERATE
					IF WIDTH_A > WIDTH_B GENERATE
						FOR k IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
							FOR i IN 0 TO WIDTH_B-1 GENERATE
								dp_mux_b.data[k][i] = ram_block[k][DP_BLOCK_ID_B(i)].portbdataout[DP_NORMALIZE_B(i)];
							END GENERATE;
						END GENERATE;
						FOR k IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
							FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO A_B_RATIO()*BYTE_SIZE-1 GENERATE
									ram_block[k][i].portadatain[j] = data_a[BYTE_POSITION(i,j)];		
								END GENERATE;
							END GENERATE;		
						END GENERATE;
					ELSE GENERATE
						FOR k IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE	
							FOR i IN 0 TO WIDTH_A-1 GENERATE
								ram_block[k][DP_BLOCK_ID_A(i)].portadatain[DP_NORMALIZE_A(i)] = data_a[i];
							END GENERATE;
						END GENERATE;
						FOR k IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
							FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO B_A_RATIO()*BYTE_SIZE-1 GENERATE
									dp_mux_b.data[k][BYTE_POSITION(i,j)] = ram_block[k][i].portbdataout[j];
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF WIDTH_A > WIDTH_B GENERATE
						FOR k IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
							dp_mux_b.data[k][] = ram_block[k][].portbdataout[0];
							FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO A_B_RATIO()-1 GENERATE
									ram_block[k][i].portadatain[j] = data_a[POSITION(i,j)];
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						FOR k IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
							ram_block[k][].portadatain[0] = data_a[];
							FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO B_A_RATIO()-1 GENERATE
									dp_mux_b.data[k][POSITION(i,j)] = ram_block[k][i].portbdataout[j];
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				IF DP_SPECIAL_BYTEENA() GENERATE
					FOR j IN 0 TO NUMBER_OF_DUAL_PORT_SEGMENTS()-1 GENERATE
						FOR i IN 0 TO NUMBER_OF_DUAL_PORT_SLICES()-1 GENERATE
							IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
								ram_block[j][i].portawe = dp_decode_a.eq[j] & byteena_a[FLOOR(i / BYTE_SIZE)] & !aclr0;
							ELSE GENERATE
								ram_block[j][i].portawe = dp_decode_a.eq[j] & byteena_a[FLOOR(i / BYTE_SIZE)];										
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
			END GENERATE;
		END GENERATE;
		-- end dual port mode
		
		-- bidir dual mode
		IF BIDIR_DUAL_PORT_MODE()& ((RAM_BLOCK_TYPE() != "AUTO" & BIDIR_DUAL_PORT_VALID_COMBINATION()) # (RAM_BLOCK_TYPE() == "AUTO" & BDP_VALID_AUTO_COMBINATION())) GENERATE
			IF SWAP_NEEDED() GENERATE
				new_ram.wren_a = wren_b;
				new_ram.wren_b = wren_a;
				new_ram.data_a[] = data_b[];
				new_ram.data_b[] = data_a[];
				new_ram.address_a[] = address_b[];
				new_ram.address_b[] = address_a[];
				IF USED(byteena_b) GENERATE
					new_ram.byteena_a[] = byteena_b[];
				END GENERATE;
				IF USED(byteena_a) GENERATE
					new_ram.byteena_b[] = byteena_a[];
				END GENERATE;
				q_a[] = new_ram.q_b[];
				q_b[] = new_ram.q_a[];
				IF SWAP_CLOCK0() == "CLOCK0" GENERATE
					new_ram.clock0 = clock0;
					IF USED(clocken0) GENERATE
						new_ram.clocken0 = clocken0;
					END GENERATE;
				END GENERATE;
				IF SWAP_CLOCK0() == "CLOCK1" GENERATE
					new_ram.clock0 = clock1;
					IF USED(clocken1) GENERATE
						new_ram.clocken0 = clocken1;
					END GENERATE;
				END GENERATE;
				IF SWAP_CLOCK1() == "CLOCK0" GENERATE
					new_ram.clock1 = clock0;
					IF USED(clocken0) GENERATE
						new_ram.clocken1 = clocken0;
					END GENERATE;
				END GENERATE;
				IF SWAP_CLOCK1() == "CLOCK1" GENERATE
					new_ram.clock1 = clock1;
					IF USED(clocken1) GENERATE
						new_ram.clocken1 = clocken1;
					END GENERATE;
				END GENERATE;
				IF SWAP_CLEAR0() == "CLEAR0" GENERATE
					new_ram.aclr0= aclr0;
				END GENERATE;
				IF SWAP_CLEAR0() == "CLEAR1" GENERATE
					new_ram.aclr0= aclr1;
				END GENERATE;
				IF SWAP_CLEAR1() == "CLEAR0" GENERATE
					new_ram.aclr1= aclr0;
				END GENERATE;
				IF SWAP_CLEAR1() == "CLEAR1" GENERATE
					new_ram.aclr1= aclr1;
				END GENERATE;
						
			ELSE GENERATE -- dont swap
			IF NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() == 1 GENERATE
				IF BDP_DONT_SPLIT() GENERATE
					ram_block[0][].portaaddr[] = address_a[];
					ram_block[0][].portbaddr[] = address_b[];
					ram_block[0][].portawe = wren_a;
					ram_block[0][].portbrewe = wren_b;
					ram_block[0][].portabyteenamasks[] = byteena_a[];
					ram_block[0][].portadatain[] = data_a[];
					ram_block[0][].portbdatain[] = data_b[];
					q_a[] = ram_block[0][].portadataout[];
					q_b[] = ram_block[0][].portbdataout[];
				ELSE GENERATE -- split up of slices		
				FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
					ram_block[0][i].portaaddr[] = address_a[];
					ram_block[0][i].portbaddr[] = address_b[];
				END GENERATE;					
				IF !BDP_SPECIAL_BYTEENA() & !BDP_MRAM_SPECIAL_BYTEENA_PORT_A() # !USED(byteena_a) GENERATE
					ram_block[0][].portawe = wren_a;
				END GENERATE;
				IF !BDP_SPECIAL_BYTEENA() & !BDP_MRAM_SPECIAL_BYTEENA_PORT_B() # !USED(byteena_b) GENERATE
					ram_block[0][].portbrewe = wren_b;
				END GENERATE;
				
				--connecting byte enable masks			
				IF (USED(byteena_a) # USED(byteena_b)) GENERATE
					IF NUMBER_OF_BIDIR_DUAL_PORT_SLICES() == 1 GENERATE
						IF USED(byteena_a) GENERATE
							IF BDP_SPECIAL_BYTEENA() # BDP_MRAM_SPECIAL_BYTEENA_PORT_A() GENERATE
								IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
									ram_block[][].portawe = wren_a & byteena_a[] & !aclr0;
								ELSE GENERATE
									ram_block[][].portawe = wren_a & byteena_a[];							
								END GENERATE;
							ELSE GENERATE
								ram_block[][].portabyteenamasks[] = byteena_a[];
							END GENERATE;
						END GENERATE;				
						IF USED(byteena_b) GENERATE
							IF BDP_SPECIAL_BYTEENA() # BDP_MRAM_SPECIAL_BYTEENA_PORT_B()  GENERATE
								IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
									ram_block[][].portbrewe = wren_b & byteena_b[] & !aclr0;
								ELSE GENERATE
									IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
										ram_block[][].portbrewe = wren_b & byteena_b[] & !aclr1;							
									ELSE GENERATE
										ram_block[][].portbrewe = wren_b & byteena_b[];							
									END GENERATE;
								END GENERATE;
							ELSE GENERATE
								ram_block[][].portbbyteenamasks[] = byteena_b[];
							END GENERATE;
						END GENERATE;				
					ELSE GENERATE			
						IF WIDTH_A > WIDTH_B GENERATE
							IF USED(byteena_a) GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO A_B_RATIO()-1 GENERATE
										IF BDP_SPECIAL_BYTEENA() GENERATE
											IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
												ram_block[0][i].portawe = wren_a & byteena_a[FLOOR(i / BYTE_SIZE)+j*FLOOR(NUMBER_OF_BIDIR_DUAL_PORT_SLICES() / BYTE_SIZE)] & !aclr0;
											ELSE GENERATE
												ram_block[0][i].portawe = wren_a & byteena_a[FLOOR(i / BYTE_SIZE)+j*FLOOR(NUMBER_OF_BIDIR_DUAL_PORT_SLICES() / BYTE_SIZE)];										
											END GENERATE;											
										ELSE GENERATE
											ram_block[0][i].portabyteenamasks[j] = byteena_a[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()];									
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
							IF USED(byteena_b) GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									IF BDP_SPECIAL_BYTEENA()  GENERATE
										IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
											ram_block[0][i].portbrewe = wren_b & byteena_b[FLOOR(i / BYTE_SIZE)] & !aclr0;
										ELSE GENERATE
											IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
												ram_block[0][i].portbrewe = wren_b & byteena_b[FLOOR(i / BYTE_SIZE)] & !aclr1;									
											ELSE GENERATE
												ram_block[0][i].portbrewe = wren_b & byteena_b[FLOOR(i / BYTE_SIZE)];									
											END GENERATE;
										END GENERATE;
									ELSE GENERATE
										IF BDP_MRAM_SPECIAL_BYTEENA_PORT_B() GENERATE
											IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
												ram_block[0][i].portbrewe = wren_b & byteena_b[i] & !aclr0;
											ELSE GENERATE
												IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
													ram_block[0][i].portbrewe = wren_b & byteena_b[i] & !aclr1;									
												ELSE GENERATE
													ram_block[0][i].portbrewe = wren_b & byteena_b[i];									
												END GENERATE;
											END GENERATE;
										ELSE GENERATE
											ram_block[0][i].portbbyteenamasks[0] = byteena_b[i];
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
						ELSE GENERATE
								IF USED(byteena_b) GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO B_A_RATIO()-1 GENERATE
										IF BDP_SPECIAL_BYTEENA() GENERATE
											IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
												ram_block[0][i].portbrewe = wren_b & byteena_b[FLOOR(i / BYTE_SIZE)+j*FLOOR(NUMBER_OF_BIDIR_DUAL_PORT_SLICES() / BYTE_SIZE)] & !aclr0;
											ELSE GENERATE
												IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
													ram_block[0][i].portbrewe = wren_b & byteena_b[FLOOR(i / BYTE_SIZE)+j*FLOOR(NUMBER_OF_BIDIR_DUAL_PORT_SLICES() / BYTE_SIZE)] & !aclr1;										
												ELSE GENERATE
													ram_block[0][i].portbrewe = wren_b & byteena_b[FLOOR(i / BYTE_SIZE)+j*FLOOR(NUMBER_OF_BIDIR_DUAL_PORT_SLICES() / BYTE_SIZE)];										
												END GENERATE;
											END GENERATE;
										ELSE GENERATE
											IF BDP_MRAM_SPECIAL_BYTEENA_PORT_B() GENERATE
												IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
													ram_block[0][i].portbrewe = wren_b & byteena_b[i] & !aclr0;
												ELSE GENERATE
													IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
														ram_block[0][i].portbrewe = wren_b & byteena_b[i] & !aclr1;									
													ELSE GENERATE
														ram_block[0][i].portbrewe = wren_b & byteena_b[i];									
													END GENERATE;
												END GENERATE;
											ELSE GENERATE
												ram_block[0][i].portbbyteenamasks[j] = byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()];									
											END GENERATE;
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
							IF USED(byteena_a) GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									IF BDP_SPECIAL_BYTEENA() GENERATE
										IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
											ram_block[0][i].portawe = wren_a & byteena_a[FLOOR(i / BYTE_SIZE)] & !aclr0;
										ELSE GENERATE
											ram_block[0][i].portawe = wren_a & byteena_a[FLOOR(i / BYTE_SIZE)];									
										END GENERATE;
									ELSE GENERATE
										IF BDP_MRAM_SPECIAL_BYTEENA_PORT_A() GENERATE
											IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
												ram_block[0][i].portawe = wren_a & byteena_a[i] & !aclr0;
											ELSE GENERATE
												ram_block[0][i].portawe = wren_a & byteena_a[i];									
											END GENERATE;
										ELSE GENERATE
											ram_block[0][i].portabyteenamasks[0] = byteena_a[i];
										END GENERATE;	
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					
					IF WIDTH_A > WIDTH_B GENERATE
						IF !(BDP_SPECIAL_BYTEENA()) GENERATE
							FOR i IN 0 TO WIDTH_B-1 GENERATE
								q_b[i] = ram_block[0][DP_BLOCK_ID_B(i)].portbdataout[DP_NORMALIZE_B(i)];
								ram_block[0][DP_BLOCK_ID_B(i)].portbdatain[DP_NORMALIZE_B(i)] = data_b[i];
							END GENERATE;
							FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO A_B_RATIO()*BYTE_SIZE-1 GENERATE
									q_a[BDP_BYTE_POSITION(i,j)] = ram_block[0][i].portadataout[j];
									ram_block[0][i].portadatain[j] = data_a[BDP_BYTE_POSITION(i,j)];		
								END GENERATE;
							END GENERATE;		
						ELSE GENERATE
							q_b[] = ram_block[0][].portbdataout[0];
							ram_block[0][].portbdatain[0] = data_b[];
							FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO A_B_RATIO()-1 GENERATE
									q_a[POSITION(i,j)] = ram_block[0][i].portadataout[j];
									ram_block[0][i].portadatain[j] = data_a[POSITION(i,j)];
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						IF (BDP_SPECIAL_BYTEENA()) GENERATE
							q_a[] = ram_block[0][].portadataout[0];
							ram_block[0][].portadatain[0] = data_a[];
							FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO B_A_RATIO()-1 GENERATE
									q_b[POSITION(i,j)] = ram_block[0][i].portbdataout[j];
									ram_block[0][i].portbdatain[j] = data_b[POSITION(i,j)];
								END GENERATE;
							END GENERATE;
						ELSE GENERATE
							FOR i IN 0 TO WIDTH_A-1 GENERATE
								q_a[i] = ram_block[0][DP_BLOCK_ID_A(i)].portadataout[DP_NORMALIZE_A(i)];
								ram_block[0][DP_BLOCK_ID_A(i)].portadatain[DP_NORMALIZE_A(i)] = data_a[i];
							END GENERATE;
							FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO B_A_RATIO()*BYTE_SIZE-1 GENERATE
									q_b[BDP_BYTE_POSITION(i,j)] = ram_block[0][i].portbdataout[j];
									ram_block[0][i].portbdatain[j] = data_b[BDP_BYTE_POSITION(i,j)];									
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					
				ELSE GENERATE
					IF WIDTH_A > WIDTH_B GENERATE
						q_b[] = ram_block[0][].portbdataout[0];
						ram_block[0][].portbdatain[0] = data_b[];
						FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
							FOR j IN 0 TO A_B_RATIO()-1 GENERATE
								q_a[POSITION(i,j)] = ram_block[0][i].portadataout[j];
								ram_block[0][i].portadatain[j] = data_a[POSITION(i,j)];
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						q_a[] = ram_block[0][].portadataout[0];
						ram_block[0][].portadatain[0] = data_a[];
						FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
							FOR j IN 0 TO B_A_RATIO()-1 GENERATE
								q_b[POSITION(i,j)] = ram_block[0][i].portbdataout[j];
								ram_block[0][i].portbdatain[j] = data_b[POSITION(i,j)];
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				END GENERATE; -- split up of slices
			-- number of segments > 1
			ELSE GENERATE
				IF NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() > 1 GENERATE
					FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-2 GENERATE
						FOR i IN 0 TO BIDIR_DUAL_PORT_ADDRESS_SIZE_A()-1 GENERATE
							ram_block[j][].portaaddr[i] = address_a[i];
						END GENERATE;
					END GENERATE;
				END GENERATE;	
				FOR i IN 0 TO BIDIR_DUAL_PORT_LAST_SEGMENT_ADDRESS_A()-1 GENERATE
					ram_block[NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1][].portaaddr[i] = address_a[i];
				END GENERATE;
				IF NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS() > 1 GENERATE
					FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-2 GENERATE
						FOR i IN 0 TO BIDIR_DUAL_PORT_ADDRESS_SIZE_B()-1 GENERATE
							ram_block[j][].portbaddr[i] = address_b[i];
						END GENERATE;
					END GENERATE;
				END GENERATE;	
				FOR i IN 0 TO BIDIR_DUAL_PORT_LAST_SEGMENT_ADDRESS_B()-1 GENERATE
					ram_block[NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1][].portbaddr[i] = address_b[i];
				END GENERATE;

				-- connecting clocks, clears and enables for the address_buffers
				IF OUTPUT_A_REGISTERED() GENERATE
					address_buffer_a[0][].clk = clock0;
					IF USED(clocken0) GENERATE
						address_buffer_a[0][].ena = clocken0;
					END GENERATE;
					IF OUTDATA_REG_A == "CLOCK0" GENERATE
						address_buffer_a[1][].clk = clock0;
						IF USED(clocken0) GENERATE
							address_buffer_a[1][].ena = clocken0;
						END GENERATE;
					ELSE GENERATE
						IF OUTDATA_REG_A == "CLOCK1" GENERATE
							address_buffer_a[1][].clk = clock1;
							IF USED(clocken1) GENERATE
								address_buffer_a[1][].ena = clocken1;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					address_buffer_a[].clk = clock0;
					IF USED(clocken0) GENERATE
						address_buffer_a[].ena = clocken0;
					END GENERATE;		
				END GENERATE;

				IF OUTPUT_B_REGISTERED() GENERATE
					IF ADDRESS_REG_B == "CLOCK0" GENERATE
						address_buffer_b[0][].clk = clock0;
						IF USED(clocken0) GENERATE
							address_buffer_b[0][].ena = clocken0;
						END GENERATE;
					ELSE GENERATE
						IF ADDRESS_REG_B == "CLOCK1" GENERATE
							address_buffer_b[0][].clk = clock1;
							IF USED(clocken1) GENERATE
								address_buffer_b[0][].ena = clocken1;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					IF OUTDATA_REG_B == "CLOCK0" GENERATE
						address_buffer_b[1][].clk = clock0;
						IF USED(clocken0) GENERATE
							address_buffer_b[1][].ena = clocken0;
						END GENERATE;
					ELSE GENERATE
						IF OUTDATA_REG_B == "CLOCK1" GENERATE
							address_buffer_b[1][].clk = clock1;
							IF USED(clocken1) GENERATE
								address_buffer_b[1][].ena = clocken1;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				ELSE GENERATE
					IF ADDRESS_REG_B == "CLOCK0" GENERATE
						address_buffer_b[].clk = clock0;
						IF USED(clocken0) GENERATE
							address_buffer_b[].ena = clocken0;
						END GENERATE;
					ELSE GENERATE
						IF ADDRESS_REG_B == "CLOCK1" GENERATE
							address_buffer_b[].clk = clock1;
							IF USED(clocken1) GENERATE
								address_buffer_b[].ena = clocken1;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				-- end clocking of buffers
			
				--connecting the data out through mux
				-- A Side
				q_a[] = bdp_mux_a.result[];
				FOR i IN BIDIR_DUAL_PORT_ADDRESS_SIZE_A() TO WIDTHAD_A-1 GENERATE
					IF OUTPUT_A_REGISTERED() GENERATE
						IF ADDRESS_ACLR_A == "CLEAR0" GENERATE
							address_buffer_a[0][i-BIDIR_DUAL_PORT_ADDRESS_SIZE_A()].d = address_a[i] & !aclr0;
						ELSE GENERATE
							address_buffer_a[0][i-BIDIR_DUAL_PORT_ADDRESS_SIZE_A()].d = address_a[i];					
						END GENERATE;
						address_buffer_a[1][].d = address_buffer_a[0][].q;
						bdp_mux_a.sel[] = address_buffer_a[1][].q;
					ELSE GENERATE
						IF ADDRESS_ACLR_A == "CLEAR0" GENERATE
							address_buffer_a[i-BIDIR_DUAL_PORT_ADDRESS_SIZE_A()].d = address_a[i] & !aclr0;
						ELSE GENERATE
							address_buffer_a[i-BIDIR_DUAL_PORT_ADDRESS_SIZE_A()].d = address_a[i];					
						END GENERATE;
						bdp_mux_a.sel[] = address_buffer_a[].q;
					END GENERATE;
				END GENERATE;

				-- B Side
				q_b[] = bdp_mux_b.result[];
				FOR i IN BIDIR_DUAL_PORT_ADDRESS_SIZE_B() TO WIDTHAD_B-1 GENERATE
					IF OUTPUT_B_REGISTERED() GENERATE
						IF ADDRESS_ACLR_B == "CLEAR0" GENERATE
							address_buffer_b[0][i-BIDIR_DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr0;
						ELSE GENERATE
							IF ADDRESS_ACLR_B == "CLEAR1" GENERATE
								address_buffer_b[0][i-BIDIR_DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr1;						
							ELSE GENERATE
								address_buffer_b[0][i-BIDIR_DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i];					
							END GENERATE;
						END GENERATE;
						address_buffer_b[1][].d = address_buffer_b[0][].q;
						bdp_mux_b.sel[] = address_buffer_b[1][].q;
					ELSE GENERATE
						IF ADDRESS_ACLR_B == "CLEAR0" GENERATE
							address_buffer_b[i-BIDIR_DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr0;
						ELSE GENERATE
							IF ADDRESS_ACLR_B == "CLEAR1" GENERATE
								address_buffer_b[i-BIDIR_DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i] & !aclr1;						
							ELSE GENERATE
								address_buffer_b[i-BIDIR_DUAL_PORT_ADDRESS_SIZE_B()].d = address_b[i];					
							END GENERATE;
						END GENERATE;
						bdp_mux_b.sel[] = address_buffer_b[].q;
					END GENERATE;
				END GENERATE;
				-- end mux			
				
				-- connecting the decode, thats providing the enable
				-- A side
				bdp_decode_a.enable = wren_a;
				FOR i IN BIDIR_DUAL_PORT_ADDRESS_SIZE_A() TO WIDTHAD_A-1 GENERATE
					bdp_decode_a.data[i-BIDIR_DUAL_PORT_ADDRESS_SIZE_A()] = address_a[i];
				END GENERATE;
				FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
					IF !BDP_SPECIAL_BYTEENA() & !BDP_MRAM_SPECIAL_BYTEENA_PORT_A() # !USED(byteena_a) GENERATE
						ram_block[i][].portawe = bdp_decode_a.eq[i];
					END GENERATE;
				END GENERATE;
			
				-- B Side	
				bdp_decode_b.enable = wren_b;
				FOR i IN BIDIR_DUAL_PORT_ADDRESS_SIZE_B() TO WIDTHAD_B-1 GENERATE
					bdp_decode_b.data[i-BIDIR_DUAL_PORT_ADDRESS_SIZE_B()] = address_b[i];
				END GENERATE;
				FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
					IF !BDP_SPECIAL_BYTEENA() & !BDP_MRAM_SPECIAL_BYTEENA_PORT_B() # !USED(byteena_b) GENERATE
						ram_block[i][].portbrewe = bdp_decode_b.eq[i];
					END GENERATE;
				END GENERATE;
				-- end decode
						
				--datain and out of the ram
				IF USED(byteena_a) # USED(byteena_b) GENERATE
					-- connecting byte enable masks
					IF NUMBER_OF_BIDIR_DUAL_PORT_SLICES() == 1 GENERATE
						IF USED(byteena_a) GENERATE
							IF BDP_SPECIAL_BYTEENA() # BDP_MRAM_SPECIAL_BYTEENA_PORT_A() GENERATE
								FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
									IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
										ram_block[j][].portawe = byteena_a[] & bdp_decode_a.eq[j] & !aclr0;
									ELSE GENERATE
										ram_block[j][].portawe = byteena_a[] & bdp_decode_a.eq[j];							
									END GENERATE;
								END GENERATE;
							ELSE GENERATE
								ram_block[][].portabyteenamasks[] = byteena_a[];						
							END GENERATE;
						END GENERATE;
						IF USED(byteena_b) GENERATE
							IF BDP_SPECIAL_BYTEENA() # BDP_MRAM_SPECIAL_BYTEENA_PORT_B() GENERATE
								FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
									IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
										ram_block[j][].portbrewe = byteena_b[] & bdp_decode_b.eq[j] & !aclr0;
									ELSE GENERATE
										IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
											ram_block[j][].portbrewe = byteena_b[] & bdp_decode_b.eq[j] & !aclr1;							
										ELSE GENERATE
											ram_block[j][].portbrewe = byteena_b[] & bdp_decode_b.eq[j];							
										END GENERATE;
									END GENERATE;
								END GENERATE;
							ELSE GENERATE
								ram_block[][].portbbyteenamasks[] = byteena_b[];
							END GENERATE;
						END GENERATE;
					ELSE GENERATE	
						IF WIDTH_A > WIDTH_B GENERATE
							IF USED(byteena_a) GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO A_B_RATIO()-1 GENERATE
										IF BDP_SPECIAL_BYTEENA() GENERATE
											FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
												IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
													ram_block[k][i].portawe = bdp_decode_a.eq[k] & byteena_a[FLOOR(i / BYTE_SIZE)+j*FLOOR(NUMBER_OF_BIDIR_DUAL_PORT_SLICES() / BYTE_SIZE)] & !aclr0;
												ELSE GENERATE
													ram_block[k][i].portawe = bdp_decode_a.eq[k] & byteena_a[FLOOR(i / BYTE_SIZE)+j*FLOOR(NUMBER_OF_BIDIR_DUAL_PORT_SLICES() / BYTE_SIZE)];										
												END GENERATE;
											END GENERATE;
										ELSE GENERATE
											ram_block[][i].portabyteenamasks[j] = byteena_a[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()];									
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
							IF USED(byteena_b) GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									IF BDP_SPECIAL_BYTEENA() GENERATE
										FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
											IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
												ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[FLOOR(i / BYTE_SIZE)] & !aclr0;
											ELSE GENERATE
												IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
													ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[FLOOR(i / BYTE_SIZE)] & !aclr1;									
												ELSE GENERATE
													ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[FLOOR(i / BYTE_SIZE)];									
												END GENERATE;
											END GENERATE;
										END GENERATE;
									ELSE GENERATE
										IF BDP_MRAM_SPECIAL_BYTEENA_PORT_B() GENERATE
											FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
												IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
													ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i] & !aclr0;
												ELSE GENERATE
													IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
														ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i] & !aclr1;									
													ELSE GENERATE
														ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i];									
													END GENERATE;
												END GENERATE;
											END GENERATE;
										ELSE GENERATE
											ram_block[][i].portbbyteenamasks[0] = byteena_b[i];								
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
						ELSE GENERATE
							IF USED(byteena_a) GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									IF BDP_SPECIAL_BYTEENA() GENERATE
										FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
											IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
												ram_block[j][i].portawe = bdp_decode_a.eq[j] & byteena_a[FLOOR(i / BYTE_SIZE)] & !aclr0;
											ELSE GENERATE
												ram_block[j][i].portawe = bdp_decode_a.eq[j] & byteena_a[FLOOR(i / BYTE_SIZE)];									
											END GENERATE;
										END GENERATE;
									ELSE GENERATE
										IF BDP_MRAM_SPECIAL_BYTEENA_PORT_B() GENERATE
											FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
												IF BYTEENA_ACLR_A == "CLEAR0" GENERATE
													ram_block[j][i].portawe = bdp_decode_a.eq[j] & byteena_a[i] & !aclr0;
												ELSE GENERATE
													ram_block[j][i].portawe = bdp_decode_a.eq[j] & byteena_a[i];									
												END GENERATE;
											END GENERATE;
										ELSE GENERATE
											ram_block[][i].portabyteenamasks[0] = byteena_a[i];								
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
							IF USED(byteena_b) GENERATE
								IF WIDTH_A == WIDTH_B GENERATE
									FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
										IF BDP_SPECIAL_BYTEENA() GENERATE								
											FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
												IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
													ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[FLOOR(i / BYTE_SIZE)] & !aclr0;
												ELSE GENERATE
													IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
														ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[FLOOR(i / BYTE_SIZE)] & !aclr1;										
													ELSE GENERATE
														ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[FLOOR(i / BYTE_SIZE)];										
													END GENERATE;
												END GENERATE;
											END GENERATE;
										ELSE GENERATE
											IF BDP_MRAM_SPECIAL_BYTEENA_PORT_B() GENERATE								
												FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
													IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
														ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i] & !aclr0;
													ELSE GENERATE
														IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
															ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i] & !aclr1;										
														ELSE GENERATE
															ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i];										
														END GENERATE;
													END GENERATE;
												END GENERATE;
											ELSE GENERATE
												ram_block[][i].portbbyteenamasks[0] = byteena_b[i];									
											END GENERATE;
										END GENERATE;
									END GENERATE;
								ELSE GENERATE
									FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
										FOR j IN 0 TO B_A_RATIO()-1 GENERATE
											IF BDP_SPECIAL_BYTEENA() GENERATE
												FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
													IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
														ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()] & !aclr0;
													ELSE GENERATE
														IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
															ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()] & !aclr1;											
														ELSE GENERATE
															ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()];											
														END GENERATE;
													END GENERATE;
												END GENERATE;
											ELSE GENERATE
												IF BDP_MRAM_SPECIAL_BYTEENA_PORT_B() GENERATE
													FOR j IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
														IF BYTEENA_ACLR_B == "CLEAR0" GENERATE
															ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()] & !aclr0;
														ELSE GENERATE
															IF BYTEENA_ACLR_B == "CLEAR1" GENERATE
																ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()] & !aclr1;											
															ELSE GENERATE
																ram_block[j][i].portbrewe = bdp_decode_b.eq[j] & byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()];											
															END GENERATE;
														END GENERATE;
													END GENERATE;
												ELSE GENERATE
													ram_block[][i].portbbyteenamasks[j] = byteena_b[i+j*NUMBER_OF_BIDIR_DUAL_PORT_SLICES()];										
												END GENERATE;
											END GENERATE;
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;	
					--connecting data 
					IF BDP_DONT_SPLIT() GENERATE
						bdp_mux_b.data[][] = ram_block[][].portbdataout[];
						bdp_mux_a.data[][] = ram_block[][].portadataout[];
						ram_block[][].portadatain[] = data_a[];
						ram_block[][].portbdatain[] = data_b[];				
					ELSE GENERATE
					IF WIDTH_A > WIDTH_B GENERATE
						IF !BDP_SPECIAL_BYTEENA() GENERATE
							FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
								FOR i IN 0 TO WIDTH_B-1 GENERATE
									bdp_mux_b.data[k][i] = ram_block[k][DP_BLOCK_ID_B(i)].portbdataout[DP_NORMALIZE_B(i)];
									ram_block[k][DP_BLOCK_ID_B(i)].portbdatain[DP_NORMALIZE_B(i)] = data_b[i];
								END GENERATE;
							END GENERATE;
							FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO A_B_RATIO()*BYTE_SIZE-1 GENERATE
										bdp_mux_a.data[k][BDP_BYTE_POSITION(i,j)] = ram_block[k][i].portadataout[j];
										ram_block[k][i].portadatain[j] = data_a[BDP_BYTE_POSITION(i,j)];		
									END GENERATE;
								END GENERATE;		
							END GENERATE;
						ELSE GENERATE
							FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
								bdp_mux_b.data[k][] = ram_block[k][].portbdataout[0];
								ram_block[k][].portbdatain[0] = data_b[];
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO A_B_RATIO()-1 GENERATE
										bdp_mux_a.data[k][POSITION(i,j)] = ram_block[k][i].portadataout[j];
										ram_block[k][i].portadatain[j] = data_a[POSITION(i,j)];
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						IF (!BDP_SPECIAL_BYTEENA()) GENERATE
							FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE	
								FOR i IN 0 TO WIDTH_A-1 GENERATE
									bdp_mux_a.data[k][i] = ram_block[k][DP_BLOCK_ID_A(i)].portadataout[DP_NORMALIZE_A(i)];
									ram_block[k][DP_BLOCK_ID_A(i)].portadatain[DP_NORMALIZE_A(i)] = data_a[i];
								END GENERATE;
							END GENERATE;
							IF WIDTH_A == WIDTH_B GENERATE
								FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE	
									FOR i IN 0 TO WIDTH_B-1 GENERATE
										bdp_mux_b.data[k][i] = ram_block[k][DP_BLOCK_ID_B(i)].portbdataout[DP_NORMALIZE_B(i)];
										ram_block[k][DP_BLOCK_ID_B(i)].portbdatain[DP_NORMALIZE_B(i)] = data_b[i];
									END GENERATE;
								END GENERATE;
							ELSE GENERATE
								FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
									FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
										FOR j IN 0 TO B_A_RATIO()*BYTE_SIZE-1 GENERATE
											bdp_mux_b.data[k][BDP_BYTE_POSITION(i,j)] = ram_block[k][i].portbdataout[j];
											ram_block[k][i].portbdatain[j] = data_b[BDP_BYTE_POSITION(i,j)];		
										END GENERATE;
									END GENERATE;
								END GENERATE;
							END GENERATE;
						ELSE GENERATE
							FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
								bdp_mux_a.data[k][] = ram_block[k][].portadataout[0];
								ram_block[k][].portadatain[0] = data_a[];
								FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
									FOR j IN 0 TO B_A_RATIO()-1 GENERATE
										bdp_mux_b.data[k][POSITION(i,j)] = ram_block[k][i].portbdataout[j];
										ram_block[k][i].portbdatain[j] = data_b[POSITION(i,j)];
									END GENERATE;
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
					
					END GENERATE;
				ELSE GENERATE
					IF WIDTH_A > WIDTH_B GENERATE
						FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
							bdp_mux_b.data[k][] = ram_block[k][].portbdataout[0];
							ram_block[k][].portbdatain[0] = data_b[];
							FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO A_B_RATIO()-1 GENERATE
									bdp_mux_a.data[k][POSITION(i,j)] = ram_block[k][i].portadataout[j];
									ram_block[k][i].portadatain[j] = data_a[POSITION(i,j)];
								END GENERATE;
							END GENERATE;
						END GENERATE;
					ELSE GENERATE
						FOR k IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SEGMENTS()-1 GENERATE
							bdp_mux_a.data[k][] = ram_block[k][].portadataout[0];
							ram_block[k][].portadatain[0] = data_a[];
							FOR i IN 0 TO NUMBER_OF_BIDIR_DUAL_PORT_SLICES()-1 GENERATE
								FOR j IN 0 TO B_A_RATIO()-1 GENERATE
									bdp_mux_b.data[k][POSITION(i,j)] = ram_block[k][i].portbdataout[j];
									ram_block[k][i].portbdatain[j] = data_b[POSITION(i,j)];								
								END GENERATE;
							END GENERATE;
						END GENERATE;
					END GENERATE;
				END GENERATE;
			END GENERATE;
			END GENERATE; -- dont swap
		END GENERATE; 
		--end bidir dual port mode
	ELSE GENERATE -- ! Stratix
		IF VALID_ROM_MODE() GENERATE
			rom.address[] = address_a[];
			q_a[] = rom.q[];
			rom.clocki = clock0;
			IF OUTPUT_A_REGISTERED() GENERATE
				IF OUTDATA_REG_A == "CLOCK0" GENERATE
					rom.clocko = clock0;
				END GENERATE;
				IF OUTDATA_REG_A == "CLOCK1" GENERATE
					rom.clocko = clock1;
				END GENERATE;
			END GENERATE;
		END GENERATE;
		IF VALID_SINGLE_PORT_MODE() GENERATE
			spram.we = wren_a;
			spram.data[] = data_a[];
			spram.address[] = address_a[];
			spram.clocki = clock0;
			q_a[] = spram.q[];
			IF OUTPUT_A_REGISTERED() GENERATE
				IF OUTDATA_REG_A == "CLOCK0" GENERATE
					spram.clocko = clock0;
				END GENERATE;
				IF OUTDATA_REG_A == "CLOCK1" GENERATE
					spram.clocko = clock1;
				END GENERATE;
			END GENERATE;
		END GENERATE;
		IF VALID_DUAL_PORT_MODE() GENERATE
				dpram.wren = wren_a;
				dpram.data[] = data_a[];
				dpram.wraddress[] = address_a[];	
				dpram.inclock	= clock0;
				IF USED(clocken0) GENERATE
					dpram.inclocken = clocken0;
				END GENERATE;
				IF USED(rden_b) GENERATE
					dpram.rden = rden_b;
				END GENERATE;
				dpram.rdaddress[] = address_b[];
				IF USED(clock1) GENERATE
					dpram.outclock = clock1;
					IF USED(clocken1) GENERATE
						dpram.outclocken = clocken1;
					END GENERATE;
				ELSE GENERATE
					IF DP_OUT_REG() == "OUTCLOCK" GENERATE
						dpram.outclock = clock0;
						IF USED(clocken0) GENERATE
							dpram.outclocken = clocken0;
						END GENERATE;
					END GENERATE;
				END GENERATE;
				IF USED(aclr0) GENERATE
					dpram.aclr = aclr0;
				ELSE GENERATE
					IF USED(aclr1) GENERATE
						dpram.aclr = aclr1;
					END GENERATE;
				END GENERATE;
				q_b[] = dpram.q[];
			END GENERATE;					
		END GENERATE;
	ELSE GENERATE
		IF (CBXI_PARAMETER != "NOTHING") GENERATE
		IF USED(wren_a) GENERATE
			auto_generated.wren_a = wren_a;
		END GENERATE;
		IF USED(wren_b) GENERATE
			auto_generated.wren_b = wren_b;
		END GENERATE;
		IF USED(data_a) GENERATE
			auto_generated.data_a[] = data_a[];
		END GENERATE;
		IF USED(data_b) GENERATE
			auto_generated.data_b[] = data_b[];
		END GENERATE;
		IF USED(address_a) GENERATE
			auto_generated.address_a[] = address_a[];
		END GENERATE;
		IF USED(address_b) GENERATE
			auto_generated.address_b[] = address_b[];
		END GENERATE;
		IF USED(clock0) GENERATE
			auto_generated.clock0 = clock0;
		END GENERATE;
		IF USED(clock1) GENERATE
			auto_generated.clock1 = clock1;
		END GENERATE;
		IF USED(clocken0) GENERATE
			auto_generated.clocken0 = clocken0;
		END GENERATE;
		IF USED(clocken1) GENERATE
			auto_generated.clocken1 = clocken1;
		END GENERATE;
		IF USED(clocken2) GENERATE
			auto_generated.clocken2 = clocken2;
		END GENERATE;
		IF USED(clocken3) GENERATE
			auto_generated.clocken3 = clocken3;
		END GENERATE;
		IF USED(rden_b) GENERATE
			auto_generated.rden_b = rden_b;
		END GENERATE;
		IF USED(rden_a) GENERATE
			auto_generated.rden_a = rden_a;
		END GENERATE;
		IF USED(aclr0) GENERATE
			auto_generated.aclr0 = aclr0;
		END GENERATE;
		IF USED(aclr1) GENERATE
			auto_generated.aclr1 = aclr1;
		END GENERATE;
		IF USED(byteena_a) GENERATE
			auto_generated.byteena_a[] = byteena_a[];
		END GENERATE;
		IF USED(byteena_b) GENERATE
			auto_generated.byteena_b[] = byteena_b[];
		END GENERATE;
		IF USED(addressstall_a) GENERATE
			auto_generated.addressstall_a = addressstall_a;
		END GENERATE;
		IF USED(addressstall_b) GENERATE
			auto_generated.addressstall_b = addressstall_b;
		END GENERATE;
		IF USED(q_a) GENERATE
			q_a[] = auto_generated.q_a[];
		END GENERATE;
		IF USED(q_b) GENERATE
			q_b[] = auto_generated.q_b[];
		END GENERATE;
		IF USED(eccstatus) GENERATE
			eccstatus[] = auto_generated.eccstatus[];
		END GENERATE;
		ELSE GENERATE
			ASSERT (0)
			REPORT "The current megafunction is configured for use with the clear box feature and cannot be used when the clear box feature is disabled"
			SEVERITY ERROR
			HELP_ID MF_CBX_ONLY_SUPPORT;
		END GENERATE;
	END GENERATE;
	IF !USED(q_a) GENERATE
		q_a[] = GND;
	END GENERATE;
	IF !USED(q_b) GENERATE
		q_b[] = GND;
	END GENERATE;
	IF !USED(eccstatus) GENERATE
		eccstatus[] = GND;
	END GENERATE;
END;

